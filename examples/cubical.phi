// =======================================================
// Φ — A Cubical, Reversible, Categorical Language
// Everything Is a Path
// =======================================================
//
// This file defines:
//
// • Terms with holes and structured editing
// • Changes as cubical paths
// • Parsing and rendering as isomorphisms
// • Repositories as higher groupoids (Pijul)
// • Hash-consed identity (Unison)
// • Lambda Calculus ↔ Interaction Calculus
// • Lambda Cube axes as composable extensions
// • Dependent types as second-order holes
// • Type checking as a reversible Xform
// • Proofs as paths, paths as edits
// • Phi defined in Phi
//
// Category theory does not appear as theory.
// It appears as invariants enforced by construction.
//
// Laws, aliases, and theorems use the Meta data types
// from meta.phi (see that file for the pattern/syntax mechanism).
//
// =======================================================

language Phi {

  // =============================================================
  // Standard library sorts
  // =============================================================
  sort List[A]
  sort Option[A]
  sort Type
  sort Xform[A,B]
  sort Context
  sort Path[A,B]
  sort Net
  sort Lex
  sort Change[A]
  sort Hole[A]

  constructor Nil[A] : List[A]
  constructor Cons[A] : A → List[A] → List[A]
  constructor None[A] : Option[A]
  constructor Some[A] : A → Option[A]

  // =============================================================
  // Meta-language imports (from meta.phi)
  // =============================================================
  
  sort Equation
  constructor Eq : Term → Term → Equation
  
  sort Law
  constructor MkLaw : String → List[Equation] → Law
  
  sort Alias
  constructor MkAlias : String → List[String] → Type → Alias
  
  sort Theorem
  constructor MkTheorem : String → List[String] → Equation → Theorem
  
  sort Axis
  constructor MkAxis : String → Type → Type → Axis

  // =====================================================
  // 0. Categorical substrate
  // =====================================================

  // Objects
  sort Obj

  // Morphisms
  sort Hom[A,B]

  // Identity
  constructor Id[A] : Hom[A,A]

  // Composition
  xform Comp : Hom[A,B] × Hom[B,C] ⇄ Hom[A,C]

  // Category laws
  law Category {
    Comp(Id, f) ≡ f
    Comp(f, Id) ≡ f
    Comp(Comp(f,g), h) ≡ Comp(f, Comp(g,h))
  }

  // Invertible morphisms (groupoid)
  sort Iso[A,B]
  xform Invert : Iso[A,B] ⇄ Iso[B,A]

  // =====================================================
  // 1. Core terms and holes
  // =====================================================

  sort Term[A]

  constructor Done[A] : A → Term[A]
  constructor Hole[A] : Term[A]

  // Terms form a groupoid under Change
  def objAlias : Alias = MkAlias("Obj", [], Term)

  // =====================================================
  // 2. Changes as cubical paths
  // =====================================================

  // A Change IS a path
  change Change[A] : Term[A] ⇄ Term[A]

  // Identity path
  constructor Refl[A] : Change[A]

  // Composition of paths
  xform Then[A] : Change[A] × Change[A] ⇄ Change[A]

  // Inverse path
  xform Sym[A] : Change[A] ⇄ Change[A]

  // Path groupoid laws
  law PathGroupoid {
    Then(Refl, c) ≡ c
    Then(c, Refl) ≡ c
    Then(c, Sym(c)) ≡ Refl
    Then(Sym(c), c) ≡ Refl
    Then(Then(a,b), c) ≡ Then(a, Then(b,c))
  }

  // Higher paths
  def path2Alias : Alias = MkAlias("Path2", ["A"], Change(Change(A)))

  // =====================================================
  // 3. Structured editing
  // =====================================================

  change Insert[A]   : A ⇄ Term[A]
  change Replace[A]  : Term[A] ⇄ Term[A]
  change Delete[A]   : Term[A] ⇄ Hole[A]

  // List of changes and choice between changes
  change Many[A]   : List[Change[A]] ⇄ Change[A]
  change Choice[A] : Change[A] × Change[A] ⇄ Change[A]

  // Editing respects holes (Kan filling)
  xform Fill : Hole[A] × Context ⇄ Term[A]

  // =====================================================
  // 4. Zippers and navigation
  // =====================================================

  sort Zipper[A]
  xform Down : Term[A] ⇄ Zipper[A]
  xform Up   : Zipper[A] ⇄ Term[A]

  law ZipperAdjunction {
    Comp(Up, Down) ≡ Id
  }

  // =====================================================
  // 5. Syntax and parsing (isomorphisms)
  // =====================================================

  sort Syntax[A]

  xform Parse  : Syntax[A] × Lex* ⇄ Term[A]
  xform Render : Term[A] ⇄ Lex*

  law RoundTrip {
    Comp(Render, Parse) ≡ Id
    Comp(Parse, Render) ≡ Id
  }

  // =====================================================
  // 6. Repository as higher groupoid (Pijul)
  // =====================================================

  sort Hash
  sort Patch[A]

  constructor Patch : Change[A] × Hash × Hash → Patch[A]

  sort Repo[A]

  xform ApplyPatch : Repo[A] × Patch[A] ⇄ Repo[A]
  xform InvertPatch : Patch[A] ⇄ Patch[A]

  law PatchGroupoid {
    ApplyPatch(r, Comp(p, InvertPatch(p))) ≡ r
  }

  // =====================================================
  // 7. Hash-consed identity (Unison)
  // =====================================================

  xform HashOf : Term[A] ⇄ Hash

  law HashExtensionality {
    Eq(HashOf(t1), HashOf(t2)) ≡ Eq(t1, t2)
  }

  // =====================================================
  // 8. Lambda Calculus (untyped)
  // =====================================================

  sort LC

  constructor Var : String → LC
  constructor Lam : String → LC → LC
  constructor App : LC → LC → LC

  def lcTermAlias : Alias = MkAlias("LCTerm", [], Term(LC))

  change Beta : LC ⇄ LC
  rule Beta {
    App(Lam(x,b), v) ↦ Subst(x,v,b)
  }

  // =====================================================
  // 9. Interaction Calculus
  // =====================================================

  constructor Node : String → List[Net]
  constructor Wire : Net × Net → Net

  change Interact : Net ⇄ Net

  // =====================================================
  // 10. LC ↔ IC (reversible compilation)
  // =====================================================

  xform LCtoIC : Term[LC] ⇄ Term[Net]
  xform ICtoLC : Term[Net] ⇄ Term[LC]

  law Simulation {
    Comp(LCtoIC, ICtoLC) ≡ Id
    Comp(ICtoLC, LCtoIC) ≡ Id
  }

  // =====================================================
  // 11. Lambda Cube axes as extensions
  // =====================================================

  constructor TyVar   : String → Type
  constructor TyArr   : Type → Type → Type
  constructor TyUniv  : Nat → Type

  // Lambda cube axes (as data)
  def arrowAxis : Axis = MkAxis("→", Term, Type)
  def polyAxis  : Axis = MkAxis("P", Type, Type)
  def omegaAxis : Axis = MkAxis("ω", Type, Term)
  def twoAxis   : Axis = MkAxis("2", Type, Type)

  // Corners are combinations of axes
  // Each axis is a functor
  // Their commutation is a natural isomorphism

  // =====================================================
  // 12. Type checking as reversible Xform
  // =====================================================

  xform TypeCheck : Term × Context ⇄ Type

  law Functoriality {
    TypeCheck(Then(c1,c2), G) ≡ Then(TypeCheck(c1,G), TypeCheck(c2,G))
  }

  // =====================================================
  // 13. Dependent types as second-order holes
  // =====================================================

  def depHoleAlias : Alias = MkAlias("DepHole", ["A"], Hole(Term(A)))

  // =====================================================
  // 14. Dependent pattern matching → IC nets
  // =====================================================

  xform CompileMatch : Term × Type ⇄ Net

  // =====================================================
  // 15. Cubical paths = changes
  // =====================================================

  // Interval
  sort I
  constructor I0 : I
  constructor I1 : I

  // Path as function from interval
  def pathAlias : Alias = MkAlias("Path", ["A"], Arr(I, Term(A)))

  xform PathAsChange : Path[A] ⇄ Change[A]

  law Cubical {
    App(PathAsChange(p), I0) ≡ source
    App(PathAsChange(p), I1) ≡ target
  }

  // =====================================================
  // 16. Phi defined in Phi (meta-circular)
  // =====================================================

  // PhiGrammar would be defined using Meta's SyntaxDecl
  // PhiRepo would be a Repo[Term] with the initial patch

  // =====================================================
  // 17. Everything commutes
  // =====================================================

  def coherenceTheorem : Theorem = MkTheorem("Coherence", [],
    Eq(Comp(Parse, Comp(Edit, Comp(TypeCheck, Comp(Compile, Render)))), Id)
  )

}
