// =======================================================
// λProlog in Phi
// Parser + Interpreter
// Examples written in *actual λProlog syntax*
// =======================================================

language λProlog {

  // =====================================================
  // Core sorts
  // =====================================================

  sort Type
  sort Term
  sort Goal
  sort Clause
  sort Program

  // =====================================================
  // Types (simple types, implicit)
  // =====================================================

  constructor TyConst : String → Type
  constructor TyArr   : Type → Type → Type

  // =====================================================
  // Terms (λProlog core)
  // =====================================================

  constructor Var   : String → Term
  constructor Const : String → Term
  constructor Lam   : String → Term → Term
  constructor App   : Term → Term → Term

  // =====================================================
  // Goals and clauses
  // =====================================================

  constructor True  : Goal
  constructor And   : Goal → Goal → Goal
  constructor Call  : Term → Goal

  constructor Clause : Term → Goal → Clause
  constructor Program : Clause* → Program

  // =====================================================
  // Substitution
  // =====================================================

  xform Subst : (String × Term) × Term ⇄ Term

  rule Subst.forward {
    ((x,v), Var(x))       ↦ v
    ((x,v), Var(y))       ↦ Var(y)           where x ≠ y
    ((x,v), Const(c))     ↦ Const(c)
    ((x,v), Lam(y, t))    ↦ Lam(y, t)        where x = y
    ((x,v), Lam(y, t))    ↦ Lam(y, Subst.forward((x,v), t))
      where x ≠ y
    ((x,v), App(f, a))    ↦ App(Subst.forward((x,v), f),
                                Subst.forward((x,v), a))
  }

  // =====================================================
  // β-reduction
  // =====================================================

  change Beta : Term ⇄ Term

  rule Beta {
    App(Lam(x, b), v) ↦ Subst.forward((x,v), b)
  }

  strategy normalizeTerm := repeat Beta

  // Main normalize strategy - apply solving rules
  strategy normalize := repeat (Solve.forward | SolveClauses.forward | Unify.forward | applySubsts.forward | substGoal.forward | Subst.forward | Beta)

  // =====================================================
  // Higher-order pattern unification (fragment)
  // =====================================================

  xform Unify : Term × Term ⇄ (String × Term)*

  rule Unify.forward {
    (Var(x), t) ↦ cons((x,t), nil)
    (t, Var(x)) ↦ cons((x,t), nil)
    (Const(c1), Const(c2)) ↦ nil where c1 = c2
    (App(f1, a1), App(f2, a2)) ↦ s1 ++ s2
      where s1 = Unify.forward(f1,f2)
        and s2 = Unify.forward(a1,a2)
  }

  // =====================================================
  // Goal solving
  // =====================================================

  xform Solve : Program × Goal ⇄ Goal

  rule Solve.forward {
    (P, True) ↦ True
    (P, And(g1, g2)) ↦ And(Solve.forward(P,g1), Solve.forward(P,g2))
    (Program(cs), Call(t)) ↦ SolveClauses.forward(cs, t)
  }

  xform SolveClauses : Clause* × Term ⇄ Goal

  rule SolveClauses.forward {
    (cons(Clause(h, b), rest), t) ↦
      Solve.forward(
        Program(cons(Clause(h, b), rest)),
        applySubsts.forward(Unify.forward(h,t), b)
      )
    (cons(_, rest), t) ↦ SolveClauses.forward(rest, t)
  }

  // =====================================================
  // Apply substitutions to goals
  // =====================================================

  xform applySubsts : (String × Term)* × Goal ⇄ Goal

  rule applySubsts.forward {
    (nil, g) ↦ g
    (cons((x,t), xs), g) ↦ applySubsts.forward(xs, substGoal.forward(x,t,g))
  }

  xform substGoal : String × Term × Goal ⇄ Goal

  rule substGoal.forward {
    (x, t, True) ↦ True
    (x, t, And(g1, g2)) ↦ And(substGoal.forward(x,t,g1), substGoal.forward(x,t,g2))
    (x, t, Call(tm)) ↦ Call(Subst.forward((x,t), tm))
  }

  // =====================================================
  // Parsing rules (Token* → AST)
  // =====================================================
  // For this demo, we use direct AST construction.
  // A full implementation would have parsing rules like:
  //   [TokId(x) | rest] ↦ Var(x)
  // etc.

  // =====================================================
  // =================== EXAMPLES ========================
  // =====================================================

  // Example program:
  //
  // parent alice.
  // parent bob.
  // ancestor X :- parent X.
  // ancestor X :- parent Y, ancestor Y.
  //
  // Represented as AST:

  def exampleProgram : Program =
    Program(cons(
      Clause(App(Const(parent), Const(alice)), True),
      cons(
        Clause(App(Const(parent), Const(bob)), True),
        cons(
          Clause(App(Const(ancestor), Var(X)), Call(App(Const(parent), Var(X)))),
          cons(
            Clause(App(Const(ancestor), Var(X)), 
                   And(Call(App(Const(parent), Var(Y))),
                       Call(App(Const(ancestor), Var(Y))))),
            nil)))))

  // Example query: ancestor alice.
  def query : Goal = Call(App(Const(ancestor), Const(alice)))

  def result : Goal = Solve.forward(exampleProgram, query)
  
  // Test substitution: subst X with alice in Var(X)
  def testSubst : Term = Subst.forward((X, Const(alice)), Var(X))
}
