// =======================================================
// Abella in Phi
// Builds upon λProlog
// =======================================================

language Abella extends λProlog {

  // =====================================================
  // Core sorts
  // =====================================================
  sort Proof
  sort Theorem
  sort Hypothesis
  sort Tactic
  sort Context

  // =====================================================
  // Constructors for Theorems and Proofs
  // =====================================================
  constructor Thm       : String → Goal → Theorem
  constructor Hyp       : String → Goal → Hypothesis
  constructor Prf       : Goal → Proof

  // =====================================================
  // Proof Tactics
  // =====================================================
  constructor Apply     : Term → Tactic
  constructor Assume    : String → Tactic
  constructor Split     : Tactic
  constructor Intros    : Tactic
  constructor Exact     : Term → Tactic
  constructor Repeat    : Tactic → Tactic
  constructor Seq       : Tactic → Tactic → Tactic
  constructor Id        : Tactic
  constructor Fail      : Tactic

  // =====================================================
  // Xforms for tactic application
  // =====================================================
  xform ApplyTactic : Tactic × Proof ⇄ Proof

  rule ApplyTactic.forward {
    (Id, p) ↦ p
    (Fail, p) ↦ p
    (Seq(t1, t2), p) ↦ ApplyTactic.forward(t2, ApplyTactic.forward(t1, p))
    (Repeat(t), p) ↦ ApplyTactic.forward(t, ApplyTactic.forward(Repeat(t), p))
    (Apply(c), Prf(g)) ↦ Prf(Call(c))
    (Assume(x), Prf(g)) ↦ Prf(And(Call(Var(x)), g))
    (Split, Prf(And(g1,g2))) ↦ Prf(And(Prf(g1), Prf(g2)))
    (Intros, Prf(Call(App(Lam(x,b),v)))) ↦ Prf(Call(Subst.forward((x,v),b)))
    (Exact(t), Prf(g)) ↦ Prf(Call(t))
  }

  // =====================================================
  // Example: trivial theorem
  // =====================================================
  // <lean>
  // theorem trivial : true :=
  //   by trivial
  // </lean>
  def trivialThm : Theorem = Thm("trivial", True)
  def trivialProof : Proof = ApplyTactic.forward(Id, Prf(True))

  // =====================================================
  // Example: modus ponens
  // <lean>
  // theorem mp {P Q : Prop} (h1 : P → Q) (h2 : P) : Q :=
  //   by apply h1; exact h2
  // </lean>
  def mpThm : Theorem = Thm("mp", Call(Const("Q")))
  def mpProof : Proof =
    ApplyTactic.forward(
      Seq(Apply(Const("h1")), Exact(Const("h2"))),
      Prf(Call(Const("Q")))
    )

  // =====================================================
  // Context management
  // =====================================================
  xform ExtendCtx : Context × Hypothesis ⇄ Context

  rule ExtendCtx.forward {
    (ctx, Hyp(x,g)) ↦ cons(Hyp(x,g), ctx)
  }

  xform ApplyCtx : Context × Tactic ⇄ Proof

  rule ApplyCtx.forward {
    (nil, t) ↦ Prf(True)
    (cons(Hyp(x,g),rest), t) ↦ ApplyTactic.forward(t, Prf(g))
  }

  // =====================================================
  // Example usage with context
  // =====================================================
  def ctx : Context = cons(Hyp("H", Call(Const("P"))), nil)
  def proofWithCtx : Proof = ApplyCtx.forward(ctx, Assume("H"))

  // =====================================================
  // Syntax declarations
  // =====================================================
  syntax "theorem" ~ ident ~ ":" ~ ident ~ ":=" ~ tactic
  syntax "proof" ~ ident ~ ":=" ~ tactic
  syntax "hypothesis" ~ ident ~ ":" ~ goal

  // Example syntax usage (AST construction)
  def synThm : Theorem = Thm("trivial", True)
  def synProof : Proof = ApplyTactic.forward(Id, Prf(True))
  def synHyp : Hypothesis = Hyp("H", Call(Const("P")))
}
