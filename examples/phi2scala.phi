// =============================================================
// Phi2Scala: Transform Phi specs to Scala code
// =============================================================
//
// Transforms Phi language specs to Scala 3 code.
// Uses scala.phi for the target AST - pretty-printing is automatic.
//
// This file defines the xform rules that GenScala.scala interprets.

language Phi2Scala {

  import "phi.phi"
  import "scala.phi"

  // =============================================================
  // Transform: Phi Spec → Scala Source
  // =============================================================
  
  xform Spec2Scala : Spec ⇄ SourceFile
  
  rule Spec2Scala.spec {
    LangSpec(name, decls) ↦ 
      SourceFile(name, [], Decls2Scala.forward(decls))
  }

  // =============================================================
  // Transform: Phi Decl* → Scala Defn*
  // =============================================================
  
  xform Decls2Scala : Decl* ⇄ Defn*
  
  rule Decls2Scala.nil {
    [] ↦ []
  }
  
  rule Decls2Scala.cons {
    [d | ds] ↦ [Decl2Scala.forward(d) | Decls2Scala.forward(ds)]
  }

  // =============================================================
  // Transform: Phi Decl → Scala Defn
  // =============================================================
  
  xform Decl2Scala : Decl ⇄ Defn
  
  // Sort → sealed trait
  rule Decl2Scala.sort {
    DSort(name) ↦ SealedTrait(name, [])
  }
  
  // Constructor with no args → case object
  rule Decl2Scala.con0 {
    DCon(name, TName(ret)) ↦ 
      CaseObject(name, TyName(SimpleName(ret)))
  }
  
  // Constructor with arrow type → case class
  rule Decl2Scala.conArrow {
    DCon(name, TArrow(arg, TName(ret))) ↦
      CaseClassExtends(name, [], [Param("arg0", Type2Scala.forward(arg))], TyName(SimpleName(ret)))
  }
  
  // Constructor with nested arrows → case class with multiple params  
  rule Decl2Scala.conArrow2 {
    DCon(name, TArrow(a, TArrow(b, TName(ret)))) ↦
      CaseClassExtends(name, [], 
        [Param("arg0", Type2Scala.forward(a)), Param("arg1", Type2Scala.forward(b))], 
        TyName(SimpleName(ret)))
  }
  
  rule Decl2Scala.conArrow3 {
    DCon(name, TArrow(a, TArrow(b, TArrow(c, TName(ret))))) ↦
      CaseClassExtends(name, [], 
        [Param("arg0", Type2Scala.forward(a)), 
         Param("arg1", Type2Scala.forward(b)), 
         Param("arg2", Type2Scala.forward(c))], 
        TyName(SimpleName(ret)))
  }
  
  rule Decl2Scala.conArrow4 {
    DCon(name, TArrow(a, TArrow(b, TArrow(c, TArrow(d, TName(ret)))))) ↦
      CaseClassExtends(name, [], 
        [Param("arg0", Type2Scala.forward(a)), 
         Param("arg1", Type2Scala.forward(b)), 
         Param("arg2", Type2Scala.forward(c)),
         Param("arg3", Type2Scala.forward(d))], 
        TyName(SimpleName(ret)))
  }
  
  // Xform declaration → method def (placeholder, actual rules needed separately)
  rule Decl2Scala.xform {
    DXform(name, src, tgt) ↦
      MethodDef(name, [], [Param("input", TyName(SimpleName(src)))], 
                TyName(SimpleName(tgt)), EVar("???"))
  }

  // =============================================================
  // Transform: Phi Type → Scala TypeRef
  // =============================================================
  
  xform Type2Scala : Type ⇄ TypeRef
  
  rule Type2Scala.name {
    TName(n) ↦ TyName(SimpleName(n))
  }
  
  rule Type2Scala.arrow {
    TArrow(a, b) ↦ TyFunc(Type2Scala.forward(a), Type2Scala.forward(b))
  }
  
  rule Type2Scala.prod {
    TProd(a, b) ↦ TyTuple([Type2Scala.forward(a), Type2Scala.forward(b)])
  }
  
  rule Type2Scala.list {
    TList(a) ↦ TyApp(SimpleName("List"), [Type2Scala.forward(a)])
  }

  // =============================================================
  // Transform: Phi Pat → Scala Pattern  
  // =============================================================
  
  xform Pat2ScalaPat : Pat ⇄ Pattern
  
  rule Pat2ScalaPat.var {
    PVar(x) ↦ PVar(x)
  }
  
  rule Pat2ScalaPat.con0 {
    PCon(name, []) ↦ PVar(name)
  }
  
  rule Pat2ScalaPat.con {
    PCon(name, args) ↦ PCon(SimpleName(name), Pats2ScalaPats.forward(args))
      where args ≠ []
  }
  
  xform Pats2ScalaPats : Pat* ⇄ Pattern*
  
  rule Pats2ScalaPats.nil {
    [] ↦ []
  }
  
  rule Pats2ScalaPats.cons {
    [p | ps] ↦ [Pat2ScalaPat.forward(p) | Pats2ScalaPats.forward(ps)]
  }

  // =============================================================
  // Transform: Phi Pat → Scala Expr (for RHS of rules)
  // =============================================================
  
  xform Pat2ScalaExpr : Pat ⇄ Expr
  
  rule Pat2ScalaExpr.var {
    PVar(x) ↦ EVar(x)
  }
  
  rule Pat2ScalaExpr.con0 {
    PCon(name, []) ↦ EVar(name)
  }
  
  rule Pat2ScalaExpr.con {
    PCon(name, args) ↦ EApp(EVar(name), Pats2ScalaExprs.forward(args))
      where args ≠ []
  }
  
  rule Pat2ScalaExpr.app {
    PApp(f, a) ↦ EApp(Pat2ScalaExpr.forward(f), [Pat2ScalaExpr.forward(a)])
  }
  
  xform Pats2ScalaExprs : Pat* ⇄ Expr*
  
  rule Pats2ScalaExprs.nil {
    [] ↦ []
  }
  
  rule Pats2ScalaExprs.cons {
    [p | ps] ↦ [Pat2ScalaExpr.forward(p) | Pats2ScalaExprs.forward(ps)]
  }

  // =============================================================
  // Transform: Rule Case → Scala Case
  // =============================================================
  
  xform RuleCase2ScalaCase : RuleCase ⇄ Case
  
  rule RuleCase2ScalaCase.simple {
    RuleCase(lhs, rhs, []) ↦ 
      CaseSimple(Pat2ScalaPat.forward(lhs), Pat2ScalaExpr.forward(rhs))
  }

  // =============================================================
  // Transform: Rule → Method with match
  // =============================================================
  
  xform Rule2Method : DRule ⇄ MethodDef
  
  rule Rule2Method.forward {
    DRule(name, Both, cases) ↦
      MethodDef(name, [], 
                [Param("input", TyName(SimpleName("Val")))],
                TyName(SimpleName("Val")),
                EMatch(EVar("input"), RuleCases2ScalaCases.forward(cases)))
  }
  
  xform RuleCases2ScalaCases : RuleCase* ⇄ Case*
  
  rule RuleCases2ScalaCases.nil {
    [] ↦ []
  }
  
  rule RuleCases2ScalaCases.cons {
    [rc | rcs] ↦ [RuleCase2ScalaCase.forward(rc) | RuleCases2ScalaCases.forward(rcs)]
  }

  // =============================================================
  // Examples
  // =============================================================
  
  // Example: DSort("Term") → sealed trait Term
  def exSort : Decl = DSort("Term")
  def exSortScala : Defn = SealedTrait("Term", [])
  
  // Example: DCon("Zero", TName("Term")) → case object Zero extends Term
  def exCon : Decl = DCon("Zero", TName("Term"))
  def exConScala : Defn = CaseObject("Zero", TyName(SimpleName("Term")))

}
