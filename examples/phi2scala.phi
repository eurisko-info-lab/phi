// =============================================================
// Phi2Scala: Transform Phi specs to Scala code
// =============================================================
//
// Transforms Phi language specs to Scala 3 code.
// Uses scala.phi for the target AST - pretty-printing is automatic.
//
// This file defines the xform rules that GenScala.scala interprets.
//
// Extended to generate:
// - Named parameters (extracted from comments or type context)
// - Scala List/tuple syntax instead of cons/nil/pair
// - Scala 3 enum syntax for sum types
// - Class definitions with methods

language Phi2Scala {

  import "phi.phi"
  import "scala.phi"

  // =============================================================
  // Transform: Phi Spec → Scala Source
  // =============================================================
  
  xform Spec2Scala : Spec ⇄ SourceFile
  
  rule Spec2Scala.spec {
    LangSpec(name, decls) ↦ 
      SourceFile(name, [], Decls2Scala.forward(decls))
  }

  // =============================================================
  // Transform: Phi Decl* → Scala Defn*
  // =============================================================
  
  xform Decls2Scala : Decl* ⇄ Defn*
  
  rule Decls2Scala.nil {
    [] ↦ []
  }
  
  rule Decls2Scala.cons {
    [d | ds] ↦ concat(Decl2Scala.forward(d), Decls2Scala.forward(ds))
  }

  // =============================================================
  // Transform: Phi Decl → Scala Defn*
  // =============================================================
  //
  // Returns a list because some decls (like xform with rules) 
  // generate multiple Scala definitions
  
  xform Decl2Scala : Decl ⇄ Defn*
  
  // Sort → sealed trait
  rule Decl2Scala.sort {
    DSort(name) ↦ [SealedTrait(name, [])]
  }
  
  // Constructor with no args → case object
  rule Decl2Scala.con0 {
    DCon(name, TName(ret)) ↦ 
      [CaseObject(name, TyName(SimpleName(ret)))]
  }
  
  // Constructor with arrow type → case class (use ArrowToParams for named params)
  rule Decl2Scala.conArrow {
    DCon(name, ty) ↦
      [CaseClassExtends(name, [], ArrowToParams.forward(ty, zero), 
                        TyName(SimpleName(ReturnType.forward(ty))))]
      where ty ≠ TName(_)
  }
  
  // Xform declaration → method def 
  rule Decl2Scala.xform {
    DXform(name, src, tgt) ↦
      [MethodDef(name, [], [Param("input", TyName(SimpleName(src)))], 
                TyName(SimpleName(tgt)), EVar("???"))]
  }
  
  // Rule → method with pattern match
  rule Decl2Scala.rule {
    DRule(name, dir, cases) ↦
      [MethodDef(
        name,
        [],
        [Param("input", TyName(SimpleName("Val")))],
        TyApp(SimpleName("Option"), [TyName(SimpleName("Val"))]),
        EMatch(EVar("input"), RuleCases2ScalaCases.forward(cases)))]
  }
  
  // Def → val definition  
  rule Decl2Scala.def {
    DDef(name, body) ↦
      [ValDefInfer(name, Pat2ScalaExpr.forward(body))]
  }
  
  // Import → import statement
  rule Decl2Scala.import {
    DImport(path, [], _) ↦ []
  }

  // =============================================================
  // Extract parameter list from arrow type (simplified)
  // =============================================================
  //
  // TArrow(A, TArrow(B, Ret)) → [Param("arg0", A), Param("arg1", B)]
  // Uses hardcoded arg0..arg4 names for simplicity
  
  xform ArrowToParams : Type × Nat ⇄ Param*
  
  rule ArrowToParams.base {
    (TName(_), _) ↦ []
  }
  
  rule ArrowToParams.arrow0 {
    (TArrow(arg, rest), zero) ↦ 
      [Param("arg0", Type2Scala.forward(arg)) | ArrowToParams.forward(rest, succ(zero))]
  }
  
  rule ArrowToParams.arrow1 {
    (TArrow(arg, rest), succ(zero)) ↦ 
      [Param("arg1", Type2Scala.forward(arg)) | ArrowToParams.forward(rest, succ(succ(zero)))]
  }
  
  rule ArrowToParams.arrow2 {
    (TArrow(arg, rest), succ(succ(zero))) ↦ 
      [Param("arg2", Type2Scala.forward(arg)) | ArrowToParams.forward(rest, succ(succ(succ(zero))))]
  }
  
  rule ArrowToParams.arrow3 {
    (TArrow(arg, rest), succ(succ(succ(zero)))) ↦ 
      [Param("arg3", Type2Scala.forward(arg)) | ArrowToParams.forward(rest, succ(succ(succ(succ(zero)))))]
  }
  
  rule ArrowToParams.arrow4 {
    (TArrow(arg, rest), succ(succ(succ(succ(zero))))) ↦ 
      [Param("arg4", Type2Scala.forward(arg)) | ArrowToParams.forward(rest, succ(succ(succ(succ(succ(zero))))))]
  }
  
  // =============================================================
  // Extract return type from arrow chain
  // =============================================================
  
  xform ReturnType : Type ⇄ String
  
  rule ReturnType.name {
    TName(n) ↦ n
  }
  
  rule ReturnType.arrow {
    TArrow(_, rest) ↦ ReturnType.forward(rest)
  }

  // =============================================================
  // Transform: Phi Type → Scala TypeRef
  // =============================================================
  
  xform Type2Scala : Type ⇄ TypeRef
  
  rule Type2Scala.name {
    TName(n) ↦ TyName(SimpleName(n))
  }
  
  rule Type2Scala.arrow {
    TArrow(a, b) ↦ TyFunc(Type2Scala.forward(a), Type2Scala.forward(b))
  }
  
  rule Type2Scala.prod {
    TProd(a, b) ↦ TyTuple([Type2Scala.forward(a), Type2Scala.forward(b)])
  }
  
  rule Type2Scala.list {
    TList(a) ↦ TyApp(SimpleName("List"), [Type2Scala.forward(a)])
  }
  
  rule Type2Scala.app {
    TApp(base, args) ↦ TyApp(SimpleName(base), Types2Scala.forward(args))
  }
  
  rule Type2Scala.var {
    TVar(n) ↦ TyName(SimpleName(n))
  }

  xform Types2Scala : Type* ⇄ TypeRef*
  
  rule Types2Scala.nil {
    [] ↦ []
  }
  
  rule Types2Scala.cons {
    [t | ts] ↦ [Type2Scala.forward(t) | Types2Scala.forward(ts)]
  }

  // =============================================================
  // Transform: Phi Pat → Scala Pattern  
  // =============================================================
  
  xform Pat2ScalaPat : Pat ⇄ Pattern
  
  rule Pat2ScalaPat.var {
    PVar(x) ↦ PVar(x)
  }
  
  rule Pat2ScalaPat.wildcard {
    PVar(_) ↦ PWildcard
  }
  
  rule Pat2ScalaPat.con0 {
    PCon(name, []) ↦ PVar(name)
  }
  
  // cons pattern → :: infix pattern
  rule Pat2ScalaPat.cons {
    PCon(cons, [h, t]) ↦ PInfix(Pat2ScalaPat.forward(h), "::", Pat2ScalaPat.forward(t))
  }
  
  // nil pattern → Nil
  rule Pat2ScalaPat.nil {
    PCon(nil, []) ↦ PVar("Nil")
  }
  
  // pair pattern → tuple pattern
  rule Pat2ScalaPat.pair {
    PCon(pair, [a, b]) ↦ PTuple([Pat2ScalaPat.forward(a), Pat2ScalaPat.forward(b)])
  }
  
  rule Pat2ScalaPat.con {
    PCon(name, args) ↦ PCon(SimpleName(name), Pats2ScalaPats.forward(args))
      where name ≠ cons and name ≠ nil and name ≠ pair and args ≠ []
  }
  
  xform Pats2ScalaPats : Pat* ⇄ Pattern*
  
  rule Pats2ScalaPats.nil {
    [] ↦ []
  }
  
  rule Pats2ScalaPats.cons {
    [p | ps] ↦ [Pat2ScalaPat.forward(p) | Pats2ScalaPats.forward(ps)]
  }

  // =============================================================
  // Transform: Phi Pat → Scala Expr (for RHS of rules)
  // =============================================================
  
  xform Pat2ScalaExpr : Pat ⇄ Expr
  
  rule Pat2ScalaExpr.var {
    PVar(x) ↦ EVar(x)
  }
  
  rule Pat2ScalaExpr.con0 {
    PCon(name, []) ↦ EVar(name)
  }
  
  // cons expression → :: infix or List(...)
  rule Pat2ScalaExpr.cons {
    PCon(cons, [h, t]) ↦ EInfix(Pat2ScalaExpr.forward(h), "::", Pat2ScalaExpr.forward(t))
  }
  
  // nil expression → Nil
  rule Pat2ScalaExpr.nil {
    PCon(nil, []) ↦ EVar("Nil")
  }
  
  // pair expression → tuple
  rule Pat2ScalaExpr.pair {
    PCon(pair, [a, b]) ↦ ETuple([Pat2ScalaExpr.forward(a), Pat2ScalaExpr.forward(b)])
  }
  
  rule Pat2ScalaExpr.con {
    PCon(name, args) ↦ EApp(EVar(name), Pats2ScalaExprs.forward(args))
      where name ≠ cons and name ≠ nil and name ≠ pair and args ≠ []
  }
  
  rule Pat2ScalaExpr.app {
    PApp(f, a) ↦ EApp(Pat2ScalaExpr.forward(f), [Pat2ScalaExpr.forward(a)])
  }
  
  // xform forward call → method call
  rule Pat2ScalaExpr.xformCall {
    PApp(PApp(PCon(name, []), PCon(forward, [])), arg) ↦
      EApp(ESelect(EVar(name), "forward"), [Pat2ScalaExpr.forward(arg)])
  }
  
  xform Pats2ScalaExprs : Pat* ⇄ Expr*
  
  rule Pats2ScalaExprs.nil {
    [] ↦ []
  }
  
  rule Pats2ScalaExprs.cons {
    [p | ps] ↦ [Pat2ScalaExpr.forward(p) | Pats2ScalaExprs.forward(ps)]
  }

  // =============================================================
  // Transform: Rule Case → Scala Case
  // =============================================================
  
  xform RuleCase2ScalaCase : RuleCase ⇄ Case
  
  rule RuleCase2ScalaCase.simple {
    RuleCase(lhs, rhs, []) ↦ 
      CaseSimple(Pat2ScalaPat.forward(lhs), 
                 ESome(Pat2ScalaExpr.forward(rhs)))
  }
  
  rule RuleCase2ScalaCase.guarded {
    RuleCase(lhs, rhs, guards) ↦
      CaseGuarded(Pat2ScalaPat.forward(lhs),
                  Guards2ScalaGuard.forward(guards),
                  ESome(Pat2ScalaExpr.forward(rhs)))
      where guards ≠ []
  }
  
  xform RuleCases2ScalaCases : RuleCase* ⇄ Case*
  
  rule RuleCases2ScalaCases.nil {
    [] ↦ [CaseSimple(PWildcard, ENone)]
  }
  
  rule RuleCases2ScalaCases.cons {
    [rc | rcs] ↦ [RuleCase2ScalaCase.forward(rc) | RuleCases2ScalaCases.forward(rcs)]
  }
  
  // =============================================================
  // Transform: Guards → Scala Guard Expression
  // =============================================================
  
  xform Guards2ScalaGuard : Guard* ⇄ Expr
  
  rule Guards2ScalaGuard.single {
    [Guard(op, lhs, rhs)] ↦
      GuardOp2Expr.forward(op, Pat2ScalaExpr.forward(lhs), Pat2ScalaExpr.forward(rhs))
  }
  
  rule Guards2ScalaGuard.multi {
    [Guard(op, lhs, rhs) | rest] ↦
      EInfix(GuardOp2Expr.forward(op, Pat2ScalaExpr.forward(lhs), Pat2ScalaExpr.forward(rhs)),
             "&&",
             Guards2ScalaGuard.forward(rest))
      where rest ≠ []
  }
  
  xform GuardOp2Expr : String × Expr × Expr ⇄ Expr
  
  rule GuardOp2Expr.eq {
    (eq, l, r) ↦ EInfix(l, "==", r)
  }
  
  rule GuardOp2Expr.neq {
    (neq, l, r) ↦ EInfix(l, "!=", r)
  }

  // =============================================================
  // Helper: parameter name from index (handled by GenScala runtime)
  // =============================================================
  
  // These are built-in helpers that map index to param name
  // paramName(0) = "arg0", paramName(1) = "arg1", etc.

  // =============================================================
  // Helper: lowercase first letter (handled by runtime)
  // =============================================================

  // toLower("MatchPat") = "matchPat"

  // =============================================================
  // Scala Option wrappers (as patterns to be expanded)
  // =============================================================
  
  // ESome(e) becomes EApp(EVar("Some"), [e])
  // ENone becomes EVar("None")
  // TyOption(t) becomes TyApp(SimpleName("Option"), [t])

  // =============================================================
  // Examples
  // =============================================================
  
  // Example: DSort("Term") → sealed trait Term
  def exSort : Decl = DSort("Term")
  def exSortScala : Defn* = [SealedTrait("Term", [])]
  
  // Example: DCon("Zero", TName("Term")) → case object Zero extends Term
  def exCon : Decl = DCon("Zero", TName("Term"))
  def exConScala : Defn* = [CaseObject("Zero", TyName(SimpleName("Term")))]

}
