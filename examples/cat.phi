// ===========================================================
// Phi : Category Theory Core + Main Theorems with Lean 4 Comments
// ===========================================================

language PhiCategoryTheory {

  // =========================================================
  // Foundations
  // =========================================================

  sort Category
  sort Object
  sort Morphism
  sort Functor
  sort NatTrans
  sort Set
  sort Diagram
  sort Proof

  constructor
    Cat    : Category
    Obj    : Category ‚Üí Object
    Hom    : Object ‚Üí Object ‚Üí Morphism
    Id     : Object ‚Üí Morphism
    Comp   : Morphism ‚Üí Morphism ‚Üí Morphism

  rule CategoryLaws {
    Comp (Id A) f ‚Ü¶ f
    Comp f (Id B) ‚Ü¶ f
    Comp f (Comp g h) ‚Ü¶ Comp (Comp f g) h
  }

  /* <lean>
  structure Category :=
    (Obj : Type)
    (Hom : Obj ‚Üí Obj ‚Üí Type)
    (id : Œ† X, Hom X X)
    (comp : Œ† {X Y Z}, Hom X Y ‚Üí Hom Y Z ‚Üí Hom X Z)
    (id_comp' : ‚àÄ {X Y} (f : Hom X Y), comp (id X) f = f)
    (comp_id' : ‚àÄ {X Y} (f : Hom X Y), comp f (id Y) = f)
    (assoc' : ‚àÄ {W X Y Z} (h : Hom W X) (g : Hom X Y) (f : Hom Y Z),
                 comp (comp h g) f = comp h (comp g f))
  </lean> */

  // =========================================================
  // Functors and Natural Transformations
  // =========================================================

  constructor
    Fun      : Category ‚Üí Category ‚Üí Functor
    MapObj   : Functor ‚Üí Object ‚Üí Object
    MapMor   : Functor ‚Üí Morphism ‚Üí Morphism

  constructor
    Nat      : Functor ‚Üí Functor ‚Üí NatTrans
    Component : NatTrans ‚Üí Object ‚Üí Morphism

  rule NatNaturality {
    Comp (MapMor G f) (Component Œ± A)
      ‚Ü¶ Comp (Component Œ± B) (MapMor F f)
  }

  /* <lean>
  structure Functor (C D : Category) :=
    (obj : C.Obj ‚Üí D.Obj)
    (map : Œ† {X Y}, C.Hom X Y ‚Üí D.Hom (obj X) (obj Y))
    (map_id' : ‚àÄ X, map (C.id X) = D.id (obj X))
    (map_comp' : ‚àÄ {X Y Z} (f : C.Hom X Y) (g : C.Hom Y Z),
                   map (C.comp f g) = D.comp (map f) (map g))
  </lean> */

  // =========================================================
  // Yoneda Lemma
  // =========================================================

  constructor
    HomF : Object ‚Üí Functor        // Hom(-, A)

  xform Yoneda : NatTrans ‚áÑ Object

  rule Yoneda.forward {
    Nat (HomF A) F ‚Ü¶ element : MapObj F A
  }

  rule Yoneda.backward {
    element : MapObj F A ‚Ü¶ Nat (HomF A) F
  }

  def YonedaExample : Proof =
    Yoneda.forward (Nat (HomF A) F)

  /* <lean>
  theorem yoneda {C : Category} (A : C.Obj) (F : C ‚•§ Type) :
    (NatTrans (HomF A) F) ‚âÉ (F.obj A) := sorry
  </lean> */

  // Example usage in Phi
  def UseYoneda1 : Proof =
    Yoneda.forward (Nat (HomF Obj1) Functor1)

  // =========================================================
  // Adjunctions
  // =========================================================

  constructor
    Adj : Functor ‚Üí Functor ‚Üí Proof

  rule Adjunction {
    Adj F G ‚Ü¶
      (Nat (Comp F G) Id,
       Nat Id (Comp G F))
  }

  theorem GeneralAdjointFunctor :
    Functor U ‚Üí
    Proof

  def FreeForgetfulAdjunction : Proof =
    Adj Free Forget

  /* <lean>
  structure Adjunction (F : C ‚•§ D) (G : D ‚•§ C) :=
    (unit : ùü≠ C ‚ü∂ F ‚ãô G)
    (counit : G ‚ãô F ‚ü∂ ùü≠ D)
    (triangle1' : ‚àÄ X, (F.map (unit.app X)) ‚â´ counit.app (F.obj X) = ùüô (F.obj X))
    (triangle2' : ‚àÄ Y, (unit.app (G.obj Y)) ‚â´ G.map (counit.app Y) = ùüô (G.obj Y))
  </lean> */

  def UseAdj1 : Proof =
    Adj Free Forget

  // =========================================================
  // Beck Monadicity
  // =========================================================

  constructor
    Monad : Functor ‚Üí Proof

  theorem Beck :
    Functor U ‚Üí
    Monad U

  def SetMonadic : Proof =
    Beck ForgetMonoid

  /* <lean>
  theorem Beck_monadicity {F : C ‚•§ D} :
    -- if F has a right adjoint and certain conditions
    Monadic F := sorry
  </lean> */

  def UseBeck1 : Proof =
    Beck ForgetMonoid

  // =========================================================
  // Density Theorem
  // =========================================================

  theorem Density :
    Functor ‚Üí
    Proof

  rule DensityRule {
    F ‚Ü¶ Colim (HomF A)
  }

  def DensityExample : Proof =
    Density Presheaf

  /* <lean>
  theorem density {F : C ‚•§ D} :
    F ‚âÉ colimit (HomF) := sorry
  </lean> */

  def UseDensity1 : Proof =
    Density YonedaF

  // =========================================================
  // Gabriel‚ÄìUlmer Duality
  // =========================================================

  sort Theory
  sort ModelCategory

  constructor
    Models : Theory ‚Üí Category

  theorem GabrielUlmer :
    Category ‚áÑ Theory

  def AlgebraicExample : Proof =
    GabrielUlmer.forward AlgebraicCategory

  /* <lean>
  theorem gabriel_ulmer {C : Category} :
    -- C is locally presentable
    C ‚âÉ Models T := sorry
  </lean> */

  // =========================================================
  // Brown Representability
  // =========================================================

  theorem Brown :
    Functor ‚Üí
    Proof

  rule BrownRule {
    F ‚Ü¶ HomF X
  }

  def CohomologyRep : Proof =
    Brown CohomologyFunctor

  /* <lean>
  theorem brown {F : C·µí·µñ ‚•§ Type} :
    -- representable if cohomological
    representable F := sorry
  </lean> */

  // =========================================================
  // Mitchell Embedding
  // =========================================================

  sort Ring
  sort Module

  constructor
    Mod : Ring ‚Üí Category

  theorem Mitchell :
    Category ‚Üí
    Proof

  def AbelianEmbedding : Proof =
    Mitchell AbelianCategory

  /* <lean>
  theorem mitchell {A : AbCategory} :
    A ‚Ü™ Module R := sorry
  </lean> */

  // =========================================================
  // Small Object Argument
  // =========================================================

  constructor
    Factor : Morphism ‚Üí Morphism ‚Üí Morphism

  theorem SmallObject :
    Morphism ‚Üí
    Proof

  rule SmallObjectRule {
    f ‚Ü¶ Factor cofibration fibration
  }

  def ModelStructure : Proof =
    SmallObject f

  /* <lean>
  theorem small_object {I : Morphism} :
    factorization_system I := sorry
  </lean> */

  // =========================================================
  // Mac Lane Coherence
  // =========================================================

  sort MonoidalCategory

  constructor
    Tensor : Object ‚Üí Object ‚Üí Object

  theorem Coherence :
    MonoidalCategory ‚Üí
    Proof

  rule CoherenceRule {
    Tensor (Tensor A B) C ‚Ü¶ Tensor A (Tensor B C)
  }

  def Strictification : Proof =
    Coherence MonoidalCat

  /* <lean>
  theorem coherence {M : MonoidalCategory} :
    strictifiable M := sorry
  </lean> */

  // =========================================================
  // Examples in Phi
  // =========================================================

  def ExampleHom : Morphism =
    Hom (Obj CatA) (Obj CatB)

  def ExampleCompose : Morphism =
    Comp (Hom ObjA ObjB) (Hom ObjB ObjC)

  def ExampleFunctor : Functor =
    Fun CatA CatB

  def ExampleNatTrans : NatTrans =
    Nat Functor1 Functor2

  def ExampleYonedaUse : Proof =
    Yoneda.forward (Nat (HomF Obj1) Functor1)

  def ExampleAdjUse : Proof =
    Adj Free Forget

}
