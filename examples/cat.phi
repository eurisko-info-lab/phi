// ===========================================================
// Phi : Category Theory Core + Main Theorems with Lean 4 Comments
// ===========================================================

language PhiCategoryTheory {

  // =========================================================
  // Foundations
  // =========================================================

  sort Category
  sort Object
  sort Morphism
  sort Functor
  sort NatTrans
  sort Set
  sort Diagram
  sort Proof

  constructor Cat    : Category
  constructor Obj    : Category ‚Üí Object
  constructor Hom    : Object ‚Üí Object ‚Üí Morphism
  constructor Id     : Object ‚Üí Morphism
  constructor Comp   : Morphism ‚Üí Morphism ‚Üí Morphism

  rule CategoryLaws.idLeft {
    Comp(Id(_), f) ‚Ü¶ f
  }
  
  rule CategoryLaws.idRight {
    Comp(f, Id(_)) ‚Ü¶ f
  }
  
  rule CategoryLaws.assoc {
    Comp(f, Comp(g, h)) ‚Ü¶ Comp(Comp(f, g), h)
  }

  /* <lean>
  structure Category :=
    (Obj : Type)
    (Hom : Obj ‚Üí Obj ‚Üí Type)
    (id : Œ† X, Hom X X)
    (comp : Œ† {X Y Z}, Hom X Y ‚Üí Hom Y Z ‚Üí Hom X Z)
    (id_comp' : ‚àÄ {X Y} (f : Hom X Y), comp (id X) f = f)
    (comp_id' : ‚àÄ {X Y} (f : Hom X Y), comp f (id Y) = f)
    (assoc' : ‚àÄ {W X Y Z} (h : Hom W X) (g : Hom X Y) (f : Hom Y Z),
                 comp (comp h g) f = comp h (comp g f))
  </lean> */

  // =========================================================
  // Functors and Natural Transformations
  // =========================================================

  constructor Fun      : Category ‚Üí Category ‚Üí Functor
  constructor MapObj   : Functor ‚Üí Object ‚Üí Object
  constructor MapMor   : Functor ‚Üí Morphism ‚Üí Morphism

  constructor Nat      : Functor ‚Üí Functor ‚Üí NatTrans
  constructor Component : NatTrans ‚Üí Object ‚Üí Morphism

  rule NatNaturality {
    Comp(MapMor(_, f), Component(Œ±, _))
      ‚Ü¶ Comp(Component(Œ±, B), MapMor(F, f))
  }

  /* <lean>
  structure Functor (C D : Category) :=
    (obj : C.Obj ‚Üí D.Obj)
    (map : Œ† {X Y}, C.Hom X Y ‚Üí D.Hom (obj X) (obj Y))
    (map_id' : ‚àÄ X, map (C.id X) = D.id (obj X))
    (map_comp' : ‚àÄ {X Y Z} (f : C.Hom X Y) (g : C.Hom Y Z),
                   map (C.comp f g) = D.comp (map f) (map g))
  </lean> */

  // =========================================================
  // Yoneda Lemma
  // =========================================================

  constructor HomF : Object ‚Üí Functor        // Hom(-, A)

  xform Yoneda : NatTrans ‚áÑ Object

  rule Yoneda.forward {
    Nat(HomF(A), F) ‚Ü¶ MapObj(F, A)
  }

  rule Yoneda.backward {
    MapObj(F, A) ‚Ü¶ Nat(HomF(A), F)
  }

  def YonedaExample : Proof =
    Yoneda.forward(Nat(HomF(A), F))

  /* <lean>
  theorem yoneda {C : Category} (A : C.Obj) (F : C ‚•§ Type) :
    (NatTrans (HomF A) F) ‚âÉ (F.obj A) := sorry
  </lean> */

  def UseYoneda1 : Proof =
    Yoneda.forward(Nat(HomF(Obj1), Functor1))

  // =========================================================
  // Adjunctions
  // =========================================================

  constructor Adj : Functor ‚Üí Functor ‚Üí Proof
  constructor UnitNat : Functor ‚Üí Functor ‚Üí NatTrans
  constructor CounitNat : Functor ‚Üí Functor ‚Üí NatTrans
  constructor Free   : Functor
  constructor Forget : Functor

  rule Adjunction {
    Adj(F, G) ‚Ü¶ pair(UnitNat(F, G), CounitNat(F, G))
  }

  theorem GeneralAdjointFunctor : Functor ‚Üí Proof

  def FreeForgetfulAdjunction : Proof =
    Adj(Free, Forget)

  /* <lean>
  structure Adjunction (F : C ‚•§ D) (G : D ‚•§ C) :=
    (unit : ùü≠ C ‚ü∂ F ‚ãô G)
    (counit : G ‚ãô F ‚ü∂ ùü≠ D)
  </lean> */

  def UseAdj1 : Proof =
    Adj(Free, Forget)

  // =========================================================
  // Beck Monadicity
  // =========================================================

  constructor Monad : Functor ‚Üí Proof
  constructor ForgetMonoid : Functor

  theorem Beck : Functor ‚Üí Monad

  def SetMonadic : Proof =
    Beck(ForgetMonoid)

  def UseBeck1 : Proof =
    Beck(ForgetMonoid)

  // =========================================================
  // Density Theorem
  // =========================================================

  constructor Colim : Functor ‚Üí Object
  constructor Presheaf : Functor
  constructor YonedaF : Functor

  theorem Density : Functor ‚Üí Proof

  rule DensityRule {
    _ ‚Ü¶ Colim(HomF(A))
  }

  def DensityExample : Proof =
    Density(Presheaf)

  def UseDensity1 : Proof =
    Density(YonedaF)

  // =========================================================
  // Gabriel-Ulmer Duality
  // =========================================================

  sort Theory
  sort ModelCategory

  constructor AlgebraicCategory : Category

  constructor Models : Theory ‚Üí Category

  theorem GabrielUlmer : Category ‚Üí Theory

  def AlgebraicExample : Proof =
    GabrielUlmer(AlgebraicCategory)

  // =========================================================
  // Brown Representability
  // =========================================================

  constructor CohomologyFunctor : Functor

  theorem Brown : Functor ‚Üí Proof

  rule BrownRule {
    _ ‚Ü¶ HomF(X)
  }

  def CohomologyRep : Proof =
    Brown(CohomologyFunctor)

  // =========================================================
  // Mitchell Embedding
  // =========================================================

  sort Ring
  sort Module

  constructor Mod : Ring ‚Üí Category
  constructor AbelianCategory : Category

  theorem Mitchell : Category ‚Üí Proof

  def AbelianEmbedding : Proof =
    Mitchell(AbelianCategory)

  // =========================================================
  // Small Object Argument
  // =========================================================

  constructor Factor : Morphism ‚Üí Morphism ‚Üí Morphism
  constructor Cofibration : Morphism  // Cofibration part of factorization
  constructor Fibration : Morphism    // Fibration part of factorization

  theorem SmallObject : Morphism ‚Üí Proof

  rule SmallObjectRule {
    _ ‚Ü¶ Factor(Cofibration, Fibration)
  }

  def ModelStructure : Proof =
    SmallObject(f)

  // =========================================================
  // Mac Lane Coherence
  // =========================================================

  sort MonoidalCategory

  constructor Tensor : Object ‚Üí Object ‚Üí Object
  constructor MonoidalCat : Category

  theorem Coherence : MonoidalCategory ‚Üí Proof

  rule CoherenceRule {
    Tensor(Tensor(A, B), C) ‚Ü¶ Tensor(A, Tensor(B, C))
  }

  def Strictification : Proof =
    Coherence(MonoidalCat)

  // =========================================================
  // Examples in Phi
  // =========================================================

  // Example categories, objects, functors for demonstrations
  constructor CatA   : Category
  constructor CatB   : Category
  constructor ObjA   : Object
  constructor ObjB   : Object
  constructor ObjC   : Object
  constructor Obj1   : Object
  constructor Functor1 : Functor
  constructor Functor2 : Functor

  def example_hom : Morphism =
    Hom(Obj(CatA), Obj(CatB))

  def example_compose : Morphism =
    Comp(Hom(ObjA, ObjB), Hom(ObjB, ObjC))

  def example_functor : Functor =
    Fun(CatA, CatB)

  def example_nat_trans : NatTrans =
    Nat(Functor1, Functor2)

  def example_yoneda : Proof =
    Yoneda.forward(Nat(HomF(Obj1), Functor1))

  def example_adj : Proof =
    Adj(Free, Forget)

  // Main normalization strategy
  strategy normalize := repeat (CategoryLaws.idLeft | CategoryLaws.idRight | CategoryLaws.assoc | CoherenceRule)
}
