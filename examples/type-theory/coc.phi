// ===========================================================
// Calculus of Constructions (CoC) — The Apex of the Lambda Cube
// ===========================================================
// The most sophisticated type system in classical type theory.
// Combines all four axes of the Lambda Cube:
//   λ→ : Terms depending on terms (functions)
//   λP : Terms depending on types (polymorphism) 
//   λω : Types depending on types (type operators)
//   λΠ : Types depending on terms (dependent types)
//
// This is the foundation of proof assistants like Coq and Lean.
// Curry-Howard: Proofs are programs, propositions are types.
// ===========================================================

language CoC {

  // =========================================================
  // Universes (Sorts)
  // =========================================================
  // CoC has two universes forming an impredicative hierarchy:
  //   Prop : Type    (propositions, proof-irrelevant)
  //   Type : Type    (types, predicative in extensions)
  
  sort Universe
  constructor Prop : Universe           // Impredicative universe of propositions
  constructor Type : Universe           // Universe of computational types
  
  // Universe ordering: Prop ⊑ Type
  xform UnivLeq : Universe → Universe ⇄ Bool
  rule UnivLeq {
    Prop, _     ↦ True                  // Prop ⊑ anything
    Type, Type  ↦ True                  // Type ⊑ Type
    Type, Prop  ↦ False                 // Type ⋢ Prop
  }

  // Universe of a Pi type (impredicativity of Prop)
  xform PiUniv : Universe → Universe ⇄ Universe
  rule PiUniv {
    _, Prop  ↦ Prop                     // ∀x:A. P : Prop (impredicative!)
    _, Type  ↦ Type                     // ∀x:A. B : Type
  }

  // =========================================================
  // Terms (Unified syntax: terms and types are the same)
  // =========================================================
  // In CoC, there's no distinction between terms and types.
  // Everything is a term, including Type and Prop themselves.
  
  sort Term
  
  // Universes as terms
  constructor Star  : Term              // Type (the universe of types)
  constructor Box   : Term              // □ (the universe of universes, for typing Type)
  
  // Variables
  constructor Var   : String → Term
  
  // Pi types: Πx:A. B  (dependent function types)
  // When x ∉ FV(B), this is just A → B
  constructor Pi    : String → Term → Term → Term
  
  // Lambda abstraction: λx:A. t
  constructor Lam   : String → Term → Term → Term
  
  // Application: t u
  constructor App   : Term → Term → Term

  // =========================================================
  // Syntactic Sugar
  // =========================================================
  
  // Non-dependent function type: A → B = Πx:A. B where x ∉ FV(B)
  xform Arrow : Term → Term ⇄ Term
  rule Arrow {
    a, b ↦ Pi("_", a, b)
  }
  
  // Universal quantifier (same as Pi, but emphasizes propositions)
  xform Forall : String → Term → Term ⇄ Term
  rule Forall {
    x, a, b ↦ Pi(x, a, b)
  }

  // =========================================================
  // Contexts (Typing environments)
  // =========================================================
  
  sort Context
  constructor Empty  : Context
  constructor Extend : Context → String → Term → Context
  
  // Context lookup
  xform Lookup : Context → String ⇄ Option[Term]
  rule Lookup {
    Empty, _                    ↦ None
    Extend(_, x, t), y | x = y  ↦ Some(t)
    Extend(ctx, _, _), y        ↦ Lookup(ctx, y)
  }
  
  // Context well-formedness (all types are valid)
  xform WfCtx : Context ⇄ Bool
  rule WfCtx {
    Empty                       ↦ True
    Extend(ctx, x, a)           ↦ and(WfCtx(ctx), IsType(ctx, a))
  }

  // =========================================================
  // Substitution (Capture-avoiding)
  // =========================================================
  
  xform Subst : String → Term → Term ⇄ Term
  rule Subst {
    _, _, Star                      ↦ Star
    _, _, Box                       ↦ Box
    x, s, Var(y) | x = y            ↦ s
    x, _, Var(y) | x ≠ y            ↦ Var(y)
    x, s, Pi(y, a, b) | x = y       ↦ Pi(y, Subst(x, s, a), b)
    x, s, Pi(y, a, b) | x ≠ y       ↦ Pi(y, Subst(x, s, a), Subst(x, s, b))
    x, s, Lam(y, a, t) | x = y      ↦ Lam(y, Subst(x, s, a), t)
    x, s, Lam(y, a, t) | x ≠ y      ↦ Lam(y, Subst(x, s, a), Subst(x, s, t))
    x, s, App(f, u)                 ↦ App(Subst(x, s, f), Subst(x, s, u))
  }

  // =========================================================
  // Reduction (Beta reduction)
  // =========================================================
  
  xform BetaStep : Term ⇄ Term
  rule BetaStep {
    App(Lam(x, _, t), u)  ↦ Subst(x, u, t)
  }
  
  // Reduce under binders (full beta reduction)
  xform Reduce : Term ⇄ Term
  rule Reduce {
    Star                        ↦ Star
    Box                         ↦ Box
    Var(x)                      ↦ Var(x)
    Pi(x, a, b)                 ↦ Pi(x, Reduce(a), Reduce(b))
    Lam(x, a, t)                ↦ Lam(x, Reduce(a), Reduce(t))
    App(Lam(x, _, t), u)        ↦ Reduce(Subst(x, u, t))
    App(f, u)                   ↦ App(Reduce(f), Reduce(u))
  }
  
  // Normalize to beta-normal form
  strategy Normalize := fixpoint Reduce

  // =========================================================
  // Beta-Equivalence (Definitional equality)
  // =========================================================
  
  xform BetaEq : Term → Term ⇄ Bool
  rule BetaEq {
    t1, t2 ↦ AlphaEq(Normalize(t1), Normalize(t2))
  }
  
  // Alpha-equivalence (structural equality up to renaming)
  xform AlphaEq : Term → Term ⇄ Bool
  rule AlphaEq {
    Star, Star                              ↦ True
    Box, Box                                ↦ True
    Var(x), Var(y)                          ↦ x = y
    Pi(x, a1, b1), Pi(y, a2, b2)            ↦ 
      and(AlphaEq(a1, a2), AlphaEq(b1, Subst(y, Var(x), b2)))
    Lam(x, a1, t1), Lam(y, a2, t2)          ↦
      and(AlphaEq(a1, a2), AlphaEq(t1, Subst(y, Var(x), t2)))
    App(f1, u1), App(f2, u2)                ↦ and(AlphaEq(f1, f2), AlphaEq(u1, u2))
    _, _                                    ↦ False
  }

  // =========================================================
  // Type Checking (Bidirectional)
  // =========================================================
  
  // Check if a term is a valid type (has sort Star or Box)
  xform IsType : Context → Term ⇄ Bool
  rule IsType {
    ctx, t ↦ 
      case Infer(ctx, t) of
        Some(Star) → True
        Some(Box)  → True
        _          → False
  }
  
  // Check if a term is a sort
  xform IsSort : Term ⇄ Bool
  rule IsSort {
    Star  ↦ True
    Box   ↦ True
    _     ↦ False
  }
  
  // Typing rules axioms:
  //   ⊢ * : □       (Star has type Box)
  //   ⊢ □ : □       (Box has type Box - simplified)
  
  // Inference: Γ ⊢ t : T
  xform Infer : Context → Term ⇄ Option[Term]
  rule Infer {
    // Axiom: * : □
    _, Star                       ↦ Some(Box)
    
    // Axiom: □ : □ (for simplicity; full CoC has no type for □)
    _, Box                        ↦ Some(Box)
    
    // Variable
    ctx, Var(x)                   ↦ Lookup(ctx, x)
    
    // Pi-formation: if A : s₁ and B : s₂ then (Πx:A. B) : s₂
    ctx, Pi(x, a, b)              ↦
      case Infer(ctx, a) of
        Some(s1) | IsSort(s1) →
          case Infer(Extend(ctx, x, a), b) of
            Some(s2) | IsSort(s2) → Some(s2)
            _ → None
        _ → None
    
    // Lambda: if Γ,x:A ⊢ t : B then Γ ⊢ λx:A.t : Πx:A.B
    ctx, Lam(x, a, t)             ↦
      case Infer(ctx, a) of
        Some(s) | IsSort(s) →
          case Infer(Extend(ctx, x, a), t) of
            Some(b) → Some(Pi(x, a, b))
            None    → None
        _ → None
    
    // Application: if f : Πx:A.B and u : A then f u : B[x:=u]
    ctx, App(f, u)                ↦
      case Infer(ctx, f) of
        Some(Pi(x, a, b)) →
          case Check(ctx, u, a) of
            True  → Some(Subst(x, u, b))
            False → None
        _ → None
  }
  
  // Type checking: Γ ⊢ t : T
  xform Check : Context → Term → Term ⇄ Bool
  rule Check {
    ctx, t, expected ↦
      case Infer(ctx, t) of
        Some(actual) → BetaEq(actual, expected)
        None         → False
  }

  // =========================================================
  // Logical Connectives (Propositions as Types)
  // =========================================================
  
  // Bottom (False): ⊥ = ∀P:*. P
  def False : Term = Pi("P", Star, Var("P"))
  
  // Top (True): ⊤ = ∀P:*. P → P
  def True : Term = Pi("P", Star, Arrow(Var("P"), Var("P")))
  
  // Negation: ¬A = A → ⊥
  xform Not : Term ⇄ Term
  rule Not { a ↦ Arrow(a, False) }
  
  // Conjunction: A ∧ B = ∀P:*. (A → B → P) → P
  xform And : Term → Term ⇄ Term
  rule And {
    a, b ↦ Pi("P", Star, Arrow(Arrow(a, Arrow(b, Var("P"))), Var("P")))
  }
  
  // Disjunction: A ∨ B = ∀P:*. (A → P) → (B → P) → P
  xform Or : Term → Term ⇄ Term
  rule Or {
    a, b ↦ Pi("P", Star, Arrow(Arrow(a, Var("P")), Arrow(Arrow(b, Var("P")), Var("P"))))
  }
  
  // Existential: ∃x:A. B = ∀P:*. (∀x:A. B → P) → P
  xform Exists : String → Term → Term ⇄ Term
  rule Exists {
    x, a, b ↦ Pi("P", Star, Arrow(Pi(x, a, Arrow(b, Var("P"))), Var("P")))
  }
  
  // Leibniz equality: a =_A b = ∀P:(A→*). P a → P b
  xform Eq : Term → Term → Term ⇄ Term
  rule Eq {
    a, t1, t2 ↦ Pi("P", Arrow(a, Star), Arrow(App(Var("P"), t1), App(Var("P"), t2)))
  }

  // =========================================================
  // Proof Terms
  // =========================================================
  
  // Identity proof: refl : ∀A:*. ∀x:A. x = x
  def refl : Term = 
    Lam("A", Star, 
      Lam("x", Var("A"),
        Lam("P", Arrow(Var("A"), Star),
          Lam("px", App(Var("P"), Var("x")),
            Var("px")))))
  
  // Symmetry: sym : ∀A:*. ∀x:A. ∀y:A. x = y → y = x
  def sym : Term =
    Lam("A", Star,
      Lam("x", Var("A"),
        Lam("y", Var("A"),
          Lam("eq", Eq(Var("A"), Var("x"), Var("y")),
            Lam("P", Arrow(Var("A"), Star),
              Lam("py", App(Var("P"), Var("y")),
                App(App(Var("eq"), Lam("z", Var("A"), Arrow(App(Var("P"), Var("z")), App(Var("P"), Var("x"))))),
                    Var("py"))))))))
  
  // Transitivity: trans : ∀A:*. ∀x:A. ∀y:A. ∀z:A. x = y → y = z → x = z
  def trans : Term =
    Lam("A", Star,
      Lam("x", Var("A"),
        Lam("y", Var("A"),
          Lam("z", Var("A"),
            Lam("eq1", Eq(Var("A"), Var("x"), Var("y")),
              Lam("eq2", Eq(Var("A"), Var("y"), Var("z")),
                Lam("P", Arrow(Var("A"), Star),
                  Lam("px", App(Var("P"), Var("x")),
                    App(App(Var("eq2"), Var("P")),
                        App(App(Var("eq1"), Var("P")), Var("px")))))))))))
  
  // Pair introduction: pair : ∀A:*. ∀B:*. A → B → A ∧ B
  def pair : Term =
    Lam("A", Star,
      Lam("B", Star,
        Lam("a", Var("A"),
          Lam("b", Var("B"),
            Lam("P", Star,
              Lam("f", Arrow(Var("A"), Arrow(Var("B"), Var("P"))),
                App(App(Var("f"), Var("a")), Var("b"))))))))
  
  // Left injection: inl : ∀A:*. ∀B:*. A → A ∨ B
  def inl : Term =
    Lam("A", Star,
      Lam("B", Star,
        Lam("a", Var("A"),
          Lam("P", Star,
            Lam("f", Arrow(Var("A"), Var("P")),
              Lam("g", Arrow(Var("B"), Var("P")),
                App(Var("f"), Var("a"))))))))
  
  // Right injection: inr : ∀A:*. ∀B:*. B → A ∨ B
  def inr : Term =
    Lam("A", Star,
      Lam("B", Star,
        Lam("b", Var("B"),
          Lam("P", Star,
            Lam("f", Arrow(Var("A"), Var("P")),
              Lam("g", Arrow(Var("B"), Var("P")),
                App(Var("g"), Var("b"))))))))

  // =========================================================
  // Natural Numbers (Church encoding)
  // =========================================================
  
  // Nat = ∀X:*. X → (X → X) → X
  def Nat : Term = Pi("X", Star, Arrow(Var("X"), Arrow(Arrow(Var("X"), Var("X")), Var("X"))))
  
  // zero : Nat = λX:*. λz:X. λs:X→X. z
  def zero : Term =
    Lam("X", Star,
      Lam("z", Var("X"),
        Lam("s", Arrow(Var("X"), Var("X")),
          Var("z"))))
  
  // succ : Nat → Nat = λn:Nat. λX:*. λz:X. λs:X→X. s (n X z s)
  def succ : Term =
    Lam("n", Nat,
      Lam("X", Star,
        Lam("z", Var("X"),
          Lam("s", Arrow(Var("X"), Var("X")),
            App(Var("s"), App(App(App(Var("n"), Var("X")), Var("z")), Var("s")))))))
  
  // one, two, three
  def one   : Term = App(succ, zero)
  def two   : Term = App(succ, one)
  def three : Term = App(succ, two)
  
  // add : Nat → Nat → Nat
  def add : Term =
    Lam("m", Nat,
      Lam("n", Nat,
        Lam("X", Star,
          Lam("z", Var("X"),
            Lam("s", Arrow(Var("X"), Var("X")),
              App(App(App(Var("m"), Var("X")), 
                      App(App(App(Var("n"), Var("X")), Var("z")), Var("s"))),
                  Var("s")))))))
  
  // mult : Nat → Nat → Nat
  def mult : Term =
    Lam("m", Nat,
      Lam("n", Nat,
        Lam("X", Star,
          Lam("z", Var("X"),
            Lam("s", Arrow(Var("X"), Var("X")),
              App(App(App(Var("m"), Var("X")), Var("z")),
                  Lam("x", Var("X"), App(App(App(Var("n"), Var("X")), Var("x")), Var("s")))))))))

  // =========================================================
  // Polymorphic Identity and Composition
  // =========================================================
  
  // id : ∀A:*. A → A
  def id : Term = Lam("A", Star, Lam("x", Var("A"), Var("x")))
  
  // compose : ∀A:*. ∀B:*. ∀C:*. (B → C) → (A → B) → A → C
  def compose : Term =
    Lam("A", Star,
      Lam("B", Star,
        Lam("C", Star,
          Lam("f", Arrow(Var("B"), Var("C")),
            Lam("g", Arrow(Var("A"), Var("B")),
              Lam("x", Var("A"),
                App(Var("f"), App(Var("g"), Var("x")))))))))

  // =========================================================
  // Type-Level Programming
  // =========================================================
  
  // Vector type: Vec A n (length-indexed lists)
  // Vec : * → Nat → *
  def Vec : Term =
    Lam("A", Star,
      Lam("n", Nat,
        Pi("X", Arrow(Nat, Star),
          Arrow(App(Var("X"), zero),
            Arrow(Pi("m", Nat, Arrow(Var("A"), Arrow(App(Var("X"), Var("m")), App(Var("X"), App(succ, Var("m")))))),
              App(Var("X"), Var("n")))))))
  
  // Finite sets: Fin n (numbers less than n)
  // Fin : Nat → *
  def Fin : Term =
    Lam("n", Nat,
      Pi("X", Arrow(Nat, Star),
        Arrow(Pi("m", Nat, App(Var("X"), App(succ, Var("m")))),
          Arrow(Pi("m", Nat, Arrow(App(Var("X"), Var("m")), App(Var("X"), App(succ, Var("m"))))),
            App(Var("X"), Var("n"))))))

  // =========================================================
  // Tests
  // =========================================================
  
  // Test: Type of identity function
  def test_id_type = Infer(Empty, id)
  // Expected: Some(Pi("A", Star, Arrow(Var("A"), Var("A"))))
  
  // Test: Type of zero
  def test_zero_type = Infer(Empty, zero)
  // Expected: Some(Nat)
  
  // Test: Type of successor
  def test_succ_type = Infer(Empty, succ)
  // Expected: Some(Arrow(Nat, Nat))
  
  // Test: 1 + 1 = 2
  def test_one_plus_one = BetaEq(App(App(add, one), one), two)
  // Expected: True
  
  // Test: 2 * 2 = 4
  def test_two_times_two = BetaEq(App(App(mult, two), two), App(succ, three))
  // Expected: True
  
  // Test: Reflexivity is well-typed
  def test_refl_type = Infer(Empty, refl)
  // Expected: Some(Pi("A", Star, Pi("x", Var("A"), Eq(Var("A"), Var("x"), Var("x")))))
  
  // Test: Star has type Box
  def test_star_type = Infer(Empty, Star)
  // Expected: Some(Box)
  
  // Test: Pi type formation
  def test_pi_type = Infer(Empty, Pi("A", Star, Arrow(Var("A"), Var("A"))))
  // Expected: Some(Star)
  
  // Test: Identity applied to Star
  def test_id_star = Normalize(App(App(id, Star), Nat))
  // Expected: Nat
  
  // Test: Composition works
  def test_compose_type = Infer(Empty, compose)
  // Expected: Some(Pi("A", Star, Pi("B", Star, Pi("C", Star, ...))))

  // =========================================================
  // Strategies
  // =========================================================
  
  strategy typecheck := Infer(Empty, _)
  strategy normalize := Normalize
  strategy equiv := BetaEq
}
