// =============================================================================
// C Language Specification
// =============================================================================
// A phi spec describing the C programming language.
// This enables parsing, analysis, and transformation of C code.

language C {

  // ===========================================================================
  // Translation Unit (top-level)
  // ===========================================================================
  
  sort TranslationUnit
  sort ExternalDecl
  
  TranslationUnit = Unit(decls: List[ExternalDecl])
  
  ExternalDecl = FunctionDef(spec: DeclSpec, decl: Declarator, body: Stmt)
               | Declaration(spec: DeclSpec, decls: List[InitDeclarator])
               | TypedefDecl(spec: DeclSpec, decls: List[Declarator])
               | StructDef(name: String, fields: List[StructField])
               | UnionDef(name: String, fields: List[StructField])
               | EnumDef(name: String, values: List[EnumValue])

  // ===========================================================================
  // Types
  // ===========================================================================
  
  sort Type
  sort DeclSpec
  sort StorageClass
  sort TypeQualifier
  sort TypeSpecifier
  
  Type = TVoid
       | TChar | TShort | TInt | TLong | TLongLong
       | TFloat | TDouble | TLongDouble
       | TSigned(inner: Type)
       | TUnsigned(inner: Type)
       | TPointer(inner: Type, quals: List[TypeQualifier])
       | TArray(inner: Type, size: Option[Expr])
       | TFunction(ret: Type, params: List[Param], variadic: Bool)
       | TStruct(name: String)
       | TUnion(name: String)
       | TEnum(name: String)
       | TTypedef(name: String)
       | TConst(inner: Type)
       | TVolatile(inner: Type)
       | TRestrict(inner: Type)
       | TAtomic(inner: Type)
  
  DeclSpec = DeclSpec(storage: Option[StorageClass], 
                      quals: List[TypeQualifier],
                      typeSpec: TypeSpecifier)
  
  StorageClass = SAuto | SRegister | SStatic | SExtern | SThreadLocal
  
  TypeQualifier = QConst | QVolatile | QRestrict | QAtomic
  
  TypeSpecifier = TSpecVoid
                | TSpecChar | TSpecShort | TSpecInt | TSpecLong
                | TSpecFloat | TSpecDouble
                | TSpecSigned | TSpecUnsigned
                | TSpecBool | TSpecComplex
                | TSpecStruct(name: Option[String], fields: Option[List[StructField]])
                | TSpecUnion(name: Option[String], fields: Option[List[StructField]])
                | TSpecEnum(name: Option[String], values: Option[List[EnumValue]])
                | TSpecTypedef(name: String)

  // ===========================================================================
  // Declarations
  // ===========================================================================
  
  sort Declarator
  sort InitDeclarator
  sort Initializer
  sort Param
  sort StructField
  sort EnumValue
  
  Declarator = DIdent(name: String)
             | DPointer(quals: List[TypeQualifier], inner: Declarator)
             | DArray(inner: Declarator, size: Option[Expr])
             | DFunction(inner: Declarator, params: List[Param])
             | DAbstract(type: Type)
  
  InitDeclarator = InitDecl(decl: Declarator, init: Option[Initializer])
  
  Initializer = InitExpr(expr: Expr)
              | InitList(inits: List[Initializer])
              | InitDesig(desig: List[Designator], init: Initializer)
  
  Param = Param(spec: DeclSpec, decl: Option[Declarator])
        | ParamVoid
        | ParamEllipsis
  
  StructField = Field(spec: DeclSpec, decls: List[Declarator], bitfield: Option[Expr])
  
  EnumValue = EnumVal(name: String, value: Option[Expr])
  
  sort Designator
  Designator = DesigIndex(index: Expr)
             | DesigField(name: String)

  // ===========================================================================
  // Statements
  // ===========================================================================
  
  sort Stmt
  
  Stmt = SEmpty
       | SExpr(expr: Expr)
       | SBlock(items: List[BlockItem])
       | SIf(cond: Expr, then: Stmt, else: Option[Stmt])
       | SSwitch(expr: Expr, body: Stmt)
       | SWhile(cond: Expr, body: Stmt)
       | SDoWhile(body: Stmt, cond: Expr)
       | SFor(init: Option[ForInit], cond: Option[Expr], step: Option[Expr], body: Stmt)
       | SGoto(label: String)
       | SContinue
       | SBreak
       | SReturn(expr: Option[Expr])
       | SLabeled(label: String, stmt: Stmt)
       | SCase(expr: Expr, stmt: Stmt)
       | SDefault(stmt: Stmt)
  
  sort BlockItem
  BlockItem = BDecl(decl: ExternalDecl)
            | BStmt(stmt: Stmt)
  
  sort ForInit
  ForInit = ForInitExpr(expr: Expr)
          | ForInitDecl(decl: ExternalDecl)

  // ===========================================================================
  // Expressions
  // ===========================================================================
  
  sort Expr
  sort UnaryOp
  sort BinaryOp
  sort AssignOp
  
  Expr = EIdent(name: String)
       | EIntLit(value: Int, suffix: String)
       | EFloatLit(value: String, suffix: String)
       | ECharLit(value: String)
       | EStringLit(value: String)
       | ECompoundLit(type: Type, init: Initializer)
       
       // Postfix
       | EIndex(array: Expr, index: Expr)
       | ECall(func: Expr, args: List[Expr])
       | EField(obj: Expr, field: String)
       | EArrow(ptr: Expr, field: String)
       | EPostInc(expr: Expr)
       | EPostDec(expr: Expr)
       
       // Unary
       | EPreInc(expr: Expr)
       | EPreDec(expr: Expr)
       | EUnary(op: UnaryOp, expr: Expr)
       | ESizeof(expr: Expr)
       | ESizeofType(type: Type)
       | EAlignof(type: Type)
       | ECast(type: Type, expr: Expr)
       
       // Binary
       | EBinary(left: Expr, op: BinaryOp, right: Expr)
       
       // Ternary
       | ECond(cond: Expr, then: Expr, else: Expr)
       
       // Assignment
       | EAssign(left: Expr, op: AssignOp, right: Expr)
       
       // Comma
       | EComma(left: Expr, right: Expr)
       
       // GNU extensions
       | EStmtExpr(stmt: Stmt)
       | EBuiltin(name: String, args: List[Expr])
  
  UnaryOp = UAddr     // &
          | UDeref    // *
          | UPlus     // +
          | UNeg      // -
          | UBitNot   // ~
          | ULogNot   // !
  
  BinaryOp = BMul | BDiv | BMod
           | BAdd | BSub
           | BShL | BShR
           | BLT | BGT | BLE | BGE
           | BEq | BNE
           | BAnd
           | BXor
           | BOr
           | BLAnd
           | BLOr
  
  AssignOp = AAssign
           | AMul | ADiv | AMod
           | AAdd | ASub
           | AShL | AShR
           | AAnd | AXor | AOr

  // ===========================================================================
  // Preprocessor (for completeness)
  // ===========================================================================
  
  sort PPDirective
  
  PPDirective = PPInclude(path: String, system: Bool)
              | PPDefine(name: String, params: Option[List[String]], body: String)
              | PPUndef(name: String)
              | PPIf(cond: String)
              | PPIfdef(name: String)
              | PPIfndef(name: String)
              | PPElif(cond: String)
              | PPElse
              | PPEndif
              | PPError(msg: String)
              | PPWarning(msg: String)
              | PPPragma(content: String)
              | PPLine(line: Int, file: Option[String])

  // ===========================================================================
  // Grammar: C Syntax
  // ===========================================================================
  
  grammar TranslationUnit {
    translation_unit ::= external_decl*
  }
  
  grammar ExternalDecl {
    external_decl ::= function_def | declaration
    
    function_def ::= decl_spec declarator compound_stmt
    
    declaration ::= decl_spec init_declarator_list? ";"
  }
  
  grammar Stmt {
    stmt ::= labeled_stmt
           | compound_stmt
           | expr_stmt
           | selection_stmt
           | iteration_stmt
           | jump_stmt
    
    labeled_stmt ::= IDENT ":" stmt
                   | "case" const_expr ":" stmt
                   | "default" ":" stmt
    
    compound_stmt ::= "{" block_item* "}"
    
    block_item ::= declaration | stmt
    
    expr_stmt ::= expr? ";"
    
    selection_stmt ::= "if" "(" expr ")" stmt ("else" stmt)?
                     | "switch" "(" expr ")" stmt
    
    iteration_stmt ::= "while" "(" expr ")" stmt
                     | "do" stmt "while" "(" expr ")" ";"
                     | "for" "(" for_init? ";" expr? ";" expr? ")" stmt
    
    jump_stmt ::= "goto" IDENT ";"
                | "continue" ";"
                | "break" ";"
                | "return" expr? ";"
  }
  
  grammar Expr {
    expr ::= assignment_expr ("," assignment_expr)*
    
    assignment_expr ::= conditional_expr
                      | unary_expr assign_op assignment_expr
    
    conditional_expr ::= logical_or_expr ("?" expr ":" conditional_expr)?
    
    logical_or_expr ::= logical_and_expr ("||" logical_and_expr)*
    logical_and_expr ::= inclusive_or_expr ("&&" inclusive_or_expr)*
    inclusive_or_expr ::= exclusive_or_expr ("|" exclusive_or_expr)*
    exclusive_or_expr ::= and_expr ("^" and_expr)*
    and_expr ::= equality_expr ("&" equality_expr)*
    equality_expr ::= relational_expr (("==" | "!=") relational_expr)*
    relational_expr ::= shift_expr (("<" | ">" | "<=" | ">=") shift_expr)*
    shift_expr ::= additive_expr (("<<" | ">>") additive_expr)*
    additive_expr ::= mult_expr (("+" | "-") mult_expr)*
    mult_expr ::= cast_expr (("*" | "/" | "%") cast_expr)*
    
    cast_expr ::= "(" type_name ")" cast_expr
                | unary_expr
    
    unary_expr ::= postfix_expr
                 | "++" unary_expr
                 | "--" unary_expr
                 | unary_op cast_expr
                 | "sizeof" unary_expr
                 | "sizeof" "(" type_name ")"
                 | "_Alignof" "(" type_name ")"
    
    unary_op ::= "&" | "*" | "+" | "-" | "~" | "!"
    
    postfix_expr ::= primary_expr postfix_op*
    
    postfix_op ::= "[" expr "]"
                 | "(" argument_list? ")"
                 | "." IDENT
                 | "->" IDENT
                 | "++"
                 | "--"
    
    primary_expr ::= IDENT
                   | INT_LIT
                   | FLOAT_LIT
                   | CHAR_LIT
                   | STRING_LIT+
                   | "(" expr ")"
                   | generic_selection
    
    argument_list ::= assignment_expr ("," assignment_expr)*
    
    assign_op ::= "=" | "*=" | "/=" | "%=" | "+=" | "-=" 
                | "<<=" | ">>=" | "&=" | "^=" | "|="
  }
  
  grammar Type {
    type_name ::= specifier_qualifier_list abstract_declarator?
    
    specifier_qualifier_list ::= (type_specifier | type_qualifier)+
    
    type_specifier ::= "void" | "char" | "short" | "int" | "long"
                     | "float" | "double" | "signed" | "unsigned"
                     | "_Bool" | "_Complex"
                     | struct_or_union_specifier
                     | enum_specifier
                     | typedef_name
    
    type_qualifier ::= "const" | "volatile" | "restrict" | "_Atomic"
    
    struct_or_union_specifier ::= ("struct" | "union") (IDENT | IDENT? "{" struct_declaration+ "}")
    
    enum_specifier ::= "enum" (IDENT | IDENT? "{" enumerator_list ","? "}")
    
    enumerator_list ::= enumerator ("," enumerator)*
    
    enumerator ::= IDENT ("=" const_expr)?
  }
  
  grammar Declarator {
    declarator ::= pointer? direct_declarator
    
    pointer ::= ("*" type_qualifier*)+
    
    direct_declarator ::= IDENT
                        | "(" declarator ")"
                        | direct_declarator "[" array_size? "]"
                        | direct_declarator "(" parameter_list ")"
                        | direct_declarator "(" identifier_list? ")"
    
    array_size ::= type_qualifier* assignment_expr?
                 | "static" type_qualifier* assignment_expr
                 | type_qualifier+ "static" assignment_expr
                 | type_qualifier* "*"
    
    parameter_list ::= parameter_decl ("," parameter_decl)* ("," "...")?
                     | "..."
    
    parameter_decl ::= decl_spec (declarator | abstract_declarator?)
    
    abstract_declarator ::= pointer
                          | pointer? direct_abstract_declarator
    
    direct_abstract_declarator ::= "(" abstract_declarator ")"
                                 | direct_abstract_declarator? "[" array_size? "]"
                                 | direct_abstract_declarator? "(" parameter_list? ")"
  }

  // ===========================================================================
  // Lexical Tokens
  // ===========================================================================
  
  grammar Tokens {
    IDENT      ::= [a-zA-Z_][a-zA-Z0-9_]*
    INT_LIT    ::= [0-9]+ [uUlL]*
                 | 0[xX][0-9a-fA-F]+ [uUlL]*
                 | 0[bB][01]+ [uUlL]*
                 | 0[0-7]+ [uUlL]*
    FLOAT_LIT  ::= [0-9]+ "." [0-9]* ([eE] [+-]? [0-9]+)? [fFlL]?
                 | [0-9]* "." [0-9]+ ([eE] [+-]? [0-9]+)? [fFlL]?
                 | [0-9]+ [eE] [+-]? [0-9]+ [fFlL]?
    CHAR_LIT   ::= "'" char_char+ "'"
    STRING_LIT ::= "\"" string_char* "\""
  }

  // ===========================================================================
  // C11 Features
  // ===========================================================================
  
  sort C11Feature
  
  C11Feature = Generic(selector: Expr, assocs: List[GenericAssoc])
             | StaticAssert(cond: Expr, msg: String)
             | Alignas(spec: Either[Type, Expr])
             | Noreturn
             | ThreadLocal
             | Atomic(type: Type)
  
  sort GenericAssoc
  GenericAssoc = GenericType(type: Type, expr: Expr)
               | GenericDefault(expr: Expr)

  // ===========================================================================
  // Attributes (C23 / GNU)
  // ===========================================================================
  
  sort Attribute
  
  Attribute = Attr(name: String, args: List[Expr])
            | AttrDeprecated(msg: Option[String])
            | AttrNodiscard(msg: Option[String])
            | AttrMaybe_unused
            | AttrFallthrough
            | AttrNoreturn
            | AttrPacked
            | AttrAligned(align: Option[Expr])
            | AttrSection(name: String)
            | AttrVisibility(vis: String)
            | AttrWeak
            | AttrAlias(target: String)
            | AttrFormat(archetype: String, fmt_idx: Int, first_arg: Int)
            | AttrNonnull(args: List[Int])
            | AttrPure
            | AttrConst
            | AttrMalloc
            | AttrWarnUnusedResult

}
