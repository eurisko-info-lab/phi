// =============================================================
// Scala Grammar: Bidirectional syntax for Scala 3
// =============================================================
//
// Defines Scala's syntax using Phi's grammar mechanism.
// Parsing and pretty-printing are automatic from the grammar.
//
// Focus: case classes, enums, objects, traits - what we need
// to generate MetaInterp.scala, PhiParser.scala, etc.

language Scala {

  // =============================================================
  // Sorts
  // =============================================================
  
  sort String
  sort Int
  sort Name
  sort TypeRef
  sort TypeParam
  sort Param
  sort Expr
  sort Pattern
  sort Literal
  sort Case
  sort Stmt
  sort Defn
  sort EnumCase
  sort Import
  sort SourceFile

  // =============================================================
  // Names
  // =============================================================
  
  constructor SimpleName : String → Name
  constructor QualName : Name → String → Name
  
  // SimpleName(n)      <-> n
  // QualName(base, n)  <-> base "." n

  // =============================================================
  // Type References
  // =============================================================
  
  constructor TyName : Name → TypeRef
  constructor TyApp : Name → TypeRef* → TypeRef
  constructor TyFunc : TypeRef → TypeRef → TypeRef
  constructor TyTuple : TypeRef* → TypeRef
  constructor TyUnit : TypeRef
  
  // TyUnit             <-> "Unit"
  // TyName(n)          <-> n
  // TyApp(n, args)     <-> n "[" args "]"
  // TyFunc(from, to)   <-> from " => " to
  // TyTuple(elems)     <-> "(" elems ")"

  // =============================================================
  // Type Parameters
  // =============================================================
  
  constructor TypeParam : String → TypeParam
  constructor TypeParamBound : String → TypeRef → TypeRef → TypeParam
  
  // TypeParam(n)                    <-> n
  // TypeParamBound(n, upper, lower) <-> n " <: " upper " >: " lower

  // =============================================================
  // Parameters
  // =============================================================
  
  constructor Param : String → TypeRef → Param
  constructor ParamDefault : String → TypeRef → Expr → Param
  
  // Param(n, ty)           <-> n ": " ty
  // ParamDefault(n, ty, d) <-> n ": " ty " = " d

  // =============================================================
  // Literals
  // =============================================================
  
  constructor LitString : String → Literal
  constructor LitInt : Int → Literal
  constructor LitTrue : Literal
  constructor LitFalse : Literal
  constructor LitNil : Literal
  
  // LitString(s)  <-> s
  // LitInt(n)     <-> n
  // LitTrue       <-> "true"
  // LitFalse      <-> "false"
  // LitNil        <-> "Nil"

  // =============================================================
  // Patterns
  // =============================================================
  
  constructor PVar : String → Pattern
  constructor PWildcard : Pattern
  constructor PLit : Literal → Pattern
  constructor PCon : Name → Pattern* → Pattern
  constructor PTuple : Pattern* → Pattern
  constructor PTyped : Pattern → TypeRef → Pattern
  constructor PInfix : Pattern → String → Pattern → Pattern
  
  // PWildcard              <-> "_"
  // PVar(n)                <-> n
  // PLit(l)                <-> l
  // PCon(n, args)          <-> n "(" args ")"
  // PTuple(elems)          <-> "(" elems ")"
  // PTyped(p, ty)          <-> p ": " ty
  // PInfix(l, op, r)       <-> l " " op " " r

  // =============================================================
  // Expressions
  // =============================================================
  
  constructor EVar : String → Expr
  constructor ELit : Literal → Expr
  constructor EApp : Expr → Expr* → Expr
  constructor ESelect : Expr → String → Expr
  constructor ELambda : Param* → Expr → Expr
  constructor EMatch : Expr → Case* → Expr
  constructor EIf : Expr → Expr → Expr → Expr
  constructor ETuple : Expr* → Expr
  constructor ENew : TypeRef → Expr* → Expr
  constructor EBlock : Stmt* → Expr → Expr
  constructor EThrow : Expr → Expr
  constructor EInfix : Expr → String → Expr → Expr
  constructor ETypeApply : Expr → TypeRef* → Expr
  
  // EVar(n)                <-> n
  // ELit(l)                <-> l
  // EApp(f, args)          <-> f "(" args ")"
  // ESelect(e, field)      <-> e "." field
  // ELambda(ps, body)      <-> "(" ps ") => " body
  // EMatch(e, cases)       <-> e " match {" cases "}"
  // EIf(c, t, f)           <-> "if " c " then " t " else " f
  // ETuple(elems)          <-> "(" elems ")"
  // ENew(ty, args)         <-> "new " ty "(" args ")"
  // EBlock(stmts, e)       <-> "{" stmts e "}"
  // EThrow(e)              <-> "throw " e
  // EInfix(l, op, r)       <-> l " " op " " r
  // ETypeApply(e, tys)     <-> e "[" tys "]"

  // =============================================================
  // Match Cases
  // =============================================================
  
  constructor CaseSimple : Pattern → Expr → Case
  constructor CaseGuard : Pattern → Expr → Expr → Case
  
  // CaseSimple(pat, body)       <-> "case " pat " => " body
  // CaseGuard(pat, guard, body) <-> "case " pat " if " guard " => " body

  // =============================================================
  // Statements
  // =============================================================
  
  constructor SVal : String → TypeRef → Expr → Stmt
  constructor SValInfer : String → Expr → Stmt
  constructor SVar : String → TypeRef → Expr → Stmt
  constructor SDef : String → TypeParam* → Param* → TypeRef → Expr → Stmt
  constructor SExpr : Expr → Stmt
  
  // SVal(n, ty, e)          <-> "val " n ": " ty " = " e
  // SValInfer(n, e)         <-> "val " n " = " e
  // SVar(n, ty, e)          <-> "var " n ": " ty " = " e
  // SDef(n, tps, ps, ret, body) <-> "def " n tps ps ": " ret " = " body
  // SExpr(e)                <-> e

  // =============================================================
  // Top-level Definitions
  // =============================================================
  
  constructor CaseClass : String → TypeParam* → Param* → Defn
  constructor CaseClassExtends : String → TypeParam* → Param* → TypeRef → Defn
  constructor CaseObject : String → TypeRef → Defn
  constructor SealedTrait : String → TypeParam* → Defn
  constructor Trait : String → TypeParam* → Defn
  constructor TraitExtends : String → TypeParam* → TypeRef* → Defn
  constructor Object : String → Defn* → Defn
  constructor ObjectExtends : String → TypeRef* → Defn* → Defn
  constructor Enum : String → TypeParam* → EnumCase* → Defn
  constructor Class : String → TypeParam* → Param* → Defn* → Defn
  constructor ValDef : String → TypeRef → Expr → Defn
  constructor ValDefInfer : String → Expr → Defn
  constructor MethodDef : String → TypeParam* → Param* → TypeRef → Expr → Defn
  constructor TypeAlias : String → TypeParam* → TypeRef → Defn

  // =============================================================
  // Syntax (bidirectional grammar for Scala)
  // =============================================================

  syntax name : String
  syntax typeRef : TypeRef
  syntax typeParam : TypeParam
  syntax param : Param
  syntax expr : Expr
  syntax pattern : Pattern
  syntax literal : Literal
  syntax scalaCase : Case
  syntax defn : Defn
  syntax enumCase : EnumCase
  syntax import_ : Import

  // ----- Names -----
  grammar name {
    IDENT                            => SimpleName
    name "." IDENT                   => QualName
  }

  // ----- Type References -----
  grammar typeRef {
    "Unit"                           => TyUnit
    name                             => TyName
    name "[" typeRef* "]"            => TyApp
    typeRef "=>" typeRef             => TyFunc
    "(" typeRef* ")"                 => TyTuple
  }

  // ----- Type Parameters -----
  grammar typeParam {
    IDENT                            => TypeParam
    IDENT "<:" typeRef ">:" typeRef  => TypeParamBound
  }

  // ----- Parameters -----
  grammar param {
    IDENT ":" typeRef                => Param
    IDENT ":" typeRef "=" expr       => ParamDefault
  }

  // ----- Literals -----
  grammar literal {
    STRING                           => LitString
    NAT                              => LitInt
    "true"                           => LitTrue
    "false"                          => LitFalse
    "Nil"                            => LitNil
  }

  // ----- Patterns -----
  grammar pattern {
    "_"                              => PWildcard
    IDENT                            => PVar
    literal                          => PLit
    name "(" pattern* ")"            => PCon
    "(" pattern* ")"                 => PTuple
    pattern ":" typeRef              => PTyped
    pattern IDENT pattern            => PInfix
  }

  // ----- Expressions -----
  grammar expr {
    IDENT                            => EVar
    literal                          => ELit
    expr "(" expr* ")"               => EApp
    expr "." IDENT                   => ESelect
    "(" param* ")" "=>" expr         => ELambda
    expr "match" "{" scalaCase* "}"  => EMatch
    "if" expr "then" expr "else" expr => EIf
    "(" expr* ")"                    => ETuple
    "new" typeRef "(" expr* ")"      => ENew
    "{" stmt* expr "}"               => EBlock
    "throw" expr                     => EThrow
    expr IDENT expr                  => EInfix
    expr "[" typeRef* "]"            => ETypeApply
  }

  // ----- Match Cases -----
  grammar scalaCase {
    "case" pattern "=>" expr         => CaseSimple
    "case" pattern "if" expr "=>" expr => CaseGuard
  }

  // ----- Top-level Definitions -----
  grammar defn {
    "case" "class" IDENT typeParam* "(" param* ")"              => CaseClass
    "case" "class" IDENT typeParam* "(" param* ")" "extends" typeRef => CaseClassExtends
    "case" "object" IDENT "extends" typeRef                     => CaseObject
    "sealed" "trait" IDENT typeParam*                           => SealedTrait
    "trait" IDENT typeParam*                                    => Trait
    "trait" IDENT typeParam* "extends" typeRef*                 => TraitExtends
    "object" IDENT "{" defn* "}"                                => Object
    "object" IDENT "extends" typeRef* "{" defn* "}"             => ObjectExtends
    "enum" IDENT typeParam* "{" enumCase* "}"                   => Enum
    "class" IDENT typeParam* "(" param* ")" "{" defn* "}"       => Class
    "val" IDENT ":" typeRef "=" expr                            => ValDef
    "val" IDENT "=" expr                                        => ValDefInfer
    "def" IDENT typeParam* "(" param* ")" ":" typeRef "=" expr  => MethodDef
    "type" IDENT typeParam* "=" typeRef                         => TypeAlias
  }

  // ----- Enum Cases -----
  grammar enumCase {
    "case" IDENT                     => EnumVal
    "case" IDENT "(" param* ")"      => EnumClass
  }

  // ----- Imports -----
  grammar import_ {
    "import" name                    => ImportName
    "import" name "._"               => ImportAll
    "import" name ".{" name* "}"     => ImportSel
  }

  // ----- Source File -----
  syntax sourceFile : SourceFile
  grammar sourceFile {
    "package" IDENT import_* defn*   => SourceFile
  }
}