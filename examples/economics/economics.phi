-- ============================================================================
-- ECONOMICS.PHI: Markets and Mechanism Design in Types
-- ============================================================================
-- Game theory, market dynamics, auctions, and economic computation.
-- Every equilibrium typed, every mechanism verified.
-- ============================================================================

-- ============================================================================
-- PART I: UTILITY AND PREFERENCES
-- ============================================================================

-- Utility: Cardinal measure of satisfaction
type Utility = Float

-- Preference relation
type Preference (a : Type) = {
  prefers : a → a → Bool,     -- x ≻ y
  indifferent : a → a → Bool, -- x ~ y
  
  -- Axioms (as proofs)
  complete : ∀ x y. prefers x y ∨ prefers y x ∨ indifferent x y,
  transitive : ∀ x y z. prefers x y → prefers y z → prefers x z,
  reflexive : ∀ x. indifferent x x
}

-- Utility function represents preferences
type UtilityFunction (a : Type) = {
  u : a → Utility,
  represents : Preference a,
  -- u(x) > u(y) ↔ x ≻ y
  valid : ∀ x y. (u x > u y) ↔ represents.prefers x y
}

-- Common utility functions
cobbDouglas : Float → Float → Float → Float → Utility
cobbDouglas alpha x y = x^alpha * y^(1 - alpha)

ces : Float → Float → Float → Float → Utility  -- Constant Elasticity of Substitution
ces rho alpha x y = (alpha * x^rho + (1-alpha) * y^rho)^(1/rho)

quasilinear : (Float → Float) → Float → Float → Utility
quasilinear v x money = v x + money

-- Risk preferences
type RiskPreference =
  | RiskAverse { concave : ∀ x y. u((x+y)/2) > (u(x) + u(y))/2 }
  | RiskNeutral { linear : ∀ x y. u((x+y)/2) = (u(x) + u(y))/2 }
  | RiskLoving { convex : ∀ x y. u((x+y)/2) < (u(x) + u(y))/2 }

-- ============================================================================
-- PART II: GAME THEORY
-- ============================================================================

-- Strategic form game
type Game (n : Nat) (actions : Vec (List a) n) = {
  players : Fin n,
  strategies : ∀ i. List (actions[i]),
  payoff : (∀ i. actions[i]) → Vec Utility n
}

-- Nash equilibrium: No unilateral deviation improves payoff
type NashEquilibrium (g : Game n a) = {
  strategy : ∀ i. g.strategies i,
  stable : ∀ i. ∀ s'. g.payoff strategy i ≥ g.payoff (strategy[i := s']) i
}

-- Classic games
prisonersDilemma : Game 2 [Cooperate | Defect]
prisonersDilemma = {
  players = 2,
  strategies = λ _ → [Cooperate, Defect],
  payoff = λ (a1, a2) → case (a1, a2) of
    (Cooperate, Cooperate) → (-1, -1)
    (Cooperate, Defect)    → (-3, 0)
    (Defect, Cooperate)    → (0, -3)
    (Defect, Defect)       → (-2, -2)
}

-- Nash equilibrium proof for PD
pdNash : NashEquilibrium prisonersDilemma
pdNash = {
  strategy = (Defect, Defect),
  stable = -- (Defect, Defect) is the unique Nash equilibrium
    λ i s' → case (i, s') of
      (0, Cooperate) → -2 ≥ -3  -- True
      (1, Cooperate) → -2 ≥ -3  -- True
}

-- Mixed strategy
type MixedStrategy (actions : List a) = Distribution a

-- Mixed Nash equilibrium
type MixedNash (g : Game n a) = {
  strategy : ∀ i. MixedStrategy (g.strategies i),
  stable : ∀ i. ∀ s'. E[g.payoff strategy i] ≥ E[g.payoff (strategy[i := s']) i]
}

-- Matching pennies (no pure Nash)
matchingPennies : Game 2 [Heads | Tails]
matchingPennies = {
  players = 2,
  strategies = λ _ → [Heads, Tails],
  payoff = λ (a1, a2) → case (a1, a2) of
    (Heads, Heads) → (1, -1)
    (Heads, Tails) → (-1, 1)
    (Tails, Heads) → (-1, 1)
    (Tails, Tails) → (1, -1)
}

-- Mixed Nash: Both play 50-50
mpMixedNash : MixedNash matchingPennies
mpMixedNash = {
  strategy = λ _ → uniform [Heads, Tails],
  stable = -- Each player is indifferent at 50-50
    λ i s' → 0 ≥ E[payoff (strategy[i := s']) i]
}

-- ============================================================================
-- PART III: MECHANISM DESIGN
-- ============================================================================

-- Mechanism: Rules of the game designed to achieve outcomes
type Mechanism (θ : Type) (a : Type) = {
  messageSpace : Type,
  outcomeFunction : (∀ i. messageSpace) → a,
  paymentRule : (∀ i. messageSpace) → Vec Float n
}

-- Dominant strategy: Optimal regardless of others
type DominantStrategy (m : Mechanism θ a) (i : Nat) = {
  strategy : θ → m.messageSpace,
  dominant : ∀ θ_i. ∀ messages. 
    u_i(m.outcome (messages[i := strategy θ_i])) ≥ 
    u_i(m.outcome (messages[i := m']))
}

-- Incentive compatibility: Truth-telling is dominant
type IncentiveCompatible (m : Mechanism θ a) = {
  truthTelling : ∀ i. DominantStrategy m i,
  honest : ∀ i. truthTelling.strategy = id  -- Report true type
}

-- Individual rationality: Participation is voluntary
type IndividuallyRational (m : Mechanism θ a) = 
  ∀ i θ_i. u_i(participate) ≥ u_i(outsideOption)

-- VCG Mechanism: The canonical IC mechanism
type VCG (θ : Type) (a : Type) = Mechanism θ a where
  outcome messages = argmax (λ a → Σ_i v_i(a, θ_i)) A
  payment i messages = max_{a} Σ_{j≠i} v_j(a, θ_j) - Σ_{j≠i} v_j(a*, θ_j)

-- Theorem: VCG is incentive compatible
vcgIC : ∀ θ a. IncentiveCompatible (VCG θ a)
vcgIC = -- Proof by showing truth-telling maximizes u_i - payment_i

-- ============================================================================
-- PART IV: AUCTIONS
-- ============================================================================

-- Auction types
type Auction (n : Nat) = {
  bidders : Fin n,
  values : Vec Float n,     -- Private values
  bids : Vec Float n,       -- Submitted bids
  allocation : Vec Float n → Fin n,  -- Winner
  payment : Vec Float n → Float      -- Winner pays
}

-- First-price sealed-bid auction
firstPrice : Auction n
firstPrice = {
  bidders = n,
  values = private,
  bids = strategic,
  allocation = λ bids → argmax bids,
  payment = λ bids → bids[argmax bids]  -- Winner pays their bid
}

-- Second-price (Vickrey) auction
secondPrice : Auction n
secondPrice = {
  bidders = n,
  values = private,
  bids = strategic,
  allocation = λ bids → argmax bids,
  payment = λ bids → secondHighest bids  -- Winner pays second-highest bid
}

-- Theorem: Second-price auction is incentive compatible
vickreyIC : IncentiveCompatible secondPrice
vickreyIC = {
  truthTelling = λ i → {
    strategy = λ v_i → v_i,  -- Bid true value
    dominant = -- Proof:
      -- If win with v_i > p: u = v_i - p > 0 ✓
      -- If lose with v_i < p: u = 0 ✓
      -- Deviating either loses profitable wins or wins unprofitable auctions
  }
}

-- English auction (ascending)
type EnglishAuction = {
  currentBid : Float,
  increment : Float,
  active : Set BidderId,
  history : List (BidderId, Float)
}

stepEnglish : EnglishAuction → Bid → EnglishAuction
stepEnglish auction bid =
  if bid.amount > auction.currentBid + auction.increment
  then { auction | 
    currentBid = bid.amount,
    history = auction.history ++ [(bid.bidder, bid.amount)]
  }
  else auction

-- Dutch auction (descending)
type DutchAuction = {
  currentPrice : Float,
  decrement : Float,
  clockSpeed : Duration
}

stepDutch : DutchAuction → DutchAuction
stepDutch auction = { auction | currentPrice = auction.currentPrice - auction.decrement }

-- Revenue equivalence theorem
revenueEquivalence : ∀ symmetric_IPV_auctions a1 a2.
  E[Revenue a1] = E[Revenue a2]

-- ============================================================================
-- PART V: MARKET DYNAMICS
-- ============================================================================

-- Supply and demand
type Market (good : Type) = {
  supply : Price → Quantity,    -- Upward sloping
  demand : Price → Quantity,    -- Downward sloping
  equilibrium : (Price, Quantity)
}

-- Market equilibrium: Supply = Demand
findEquilibrium : Market g → (Price, Quantity)
findEquilibrium m = 
  let p* = solve (λ p → m.supply p = m.demand p)
  (p*, m.supply p*)

-- Consumer and producer surplus
consumerSurplus : Market g → Float
consumerSurplus m = integrate (λ p → m.demand p) m.equilibrium.price ∞

producerSurplus : Market g → Float
producerSurplus m = integrate (λ p → m.supply p) 0 m.equilibrium.price

-- Walrasian equilibrium (general equilibrium)
type WalrasianEquilibrium (goods : List Type) = {
  prices : Vec Price (length goods),
  allocations : ∀ agent. Vec Quantity (length goods),
  
  -- Market clearing
  clearing : ∀ g. Σ_i allocations[i][g] = Σ_j endowments[j][g],
  
  -- Utility maximization
  optimal : ∀ i. allocations[i] = argmax u_i subject to budget[i]
}

-- First welfare theorem
firstWelfare : WalrasianEquilibrium → ParetoOptimal
firstWelfare eq = -- Proof: Competitive equilibria are Pareto optimal

-- Second welfare theorem
secondWelfare : ParetoOptimal → ∃ transfers. WalrasianEquilibrium
secondWelfare po = -- Any Pareto optimum can be achieved via competitive market + transfers

-- ============================================================================
-- PART VI: CONTRACT THEORY
-- ============================================================================

-- Principal-agent problem
type PrincipalAgent = {
  principal : Agent,
  agent : Agent,
  hiddenAction : Bool,    -- Moral hazard
  hiddenType : Bool,      -- Adverse selection
  contract : Contract
}

type Contract = {
  payment : Outcome → Float,
  effort : EffortLevel,
  participation : IR,      -- Individual rationality constraint
  incentive : IC           -- Incentive compatibility constraint
}

-- Moral hazard: Agent's effort is unobservable
type MoralHazard = PrincipalAgent where hiddenAction = true

-- Optimal contract under moral hazard
optimalMH : MoralHazard → Contract
optimalMH pa = 
  let effort* = argmax_{e} (principal_payoff - E[wage | e])
  let wage* = solve incentiveConstraint effort*
  { payment = wage*, effort = effort* }

-- Adverse selection: Agent's type is unobservable
type AdverseSelection = PrincipalAgent where hiddenType = true

-- Screening: Principal offers menu of contracts
type Menu = List Contract

screening : AdverseSelection → Menu
screening as = 
  -- Design menu such that each type self-selects appropriate contract
  [contract_high, contract_low] where
    -- High type gets efficient allocation
    -- Low type gets distorted allocation to prevent mimicking

-- ============================================================================
-- PART VII: SOCIAL CHOICE
-- ============================================================================

-- Social choice function
type SocialChoiceFunction (n : Nat) (a : Type) = 
  Vec (Preference a) n → a

-- Voting rules
majority : SocialChoiceFunction n (Fin 2)
majority prefs = 
  if count (λ p → p.prefers 0 1) prefs > n/2 then 0 else 1

plurality : SocialChoiceFunction n a
plurality prefs = mode (map top prefs)

borda : SocialChoiceFunction n a
borda prefs = argmax (λ a → Σ_i (n - rank_i(a))) alternatives

-- Arrow's impossibility theorem
type ArrowAxioms (f : SocialChoiceFunction n a) = {
  unrestricted : ∀ profiles. ∃ outcome,
  pareto : ∀ x y. (∀ i. prefs[i].prefers x y) → socialPrefers x y,
  iia : ∀ x y profiles1 profiles2.
    (∀ i. relative_order x y profiles1[i] = relative_order x y profiles2[i]) →
    (socialPrefers x y profiles1 ↔ socialPrefers x y profiles2),
  nonDictator : ¬∃ i. ∀ x y profiles. prefs[i].prefers x y → socialPrefers x y
}

-- Arrow: No social choice function satisfies all axioms (for |A| ≥ 3)
arrowImpossibility : |a| ≥ 3 → ¬∃ f. ArrowAxioms f

-- Gibbard-Satterthwaite: Non-dictatorial mechanisms are manipulable
gibbardSatterthwaite : |a| ≥ 3 → NonDictatorial f → ∃ manipulation. profitable

-- ============================================================================
-- PART VIII: BEHAVIORAL ECONOMICS
-- ============================================================================

-- Prospect theory: Non-linear probability weighting
type ProspectTheory = {
  value : Float → Float,     -- Value function (loss averse)
  weight : Float → Float,    -- Probability weighting
  reference : Float          -- Reference point
}

prospectValue : ProspectTheory → Float → Float
prospectValue pt x = 
  if x >= pt.reference 
  then (x - pt.reference)^0.88                    -- Gains: concave
  else -2.25 * (pt.reference - x)^0.88           -- Losses: convex, steeper

probabilityWeight : Float → Float
probabilityWeight p = p^0.61 / (p^0.61 + (1-p)^0.61)^(1/0.61)

-- Hyperbolic discounting (time inconsistency)
hyperbolicDiscount : Float → Float → Float → Float
hyperbolicDiscount beta delta t = beta * delta^t

-- Present bias: β < 1 overweights present
presentBias : Float → Float → Float → Utility → Utility
presentBias beta delta t u = 
  if t = 0 then u
  else beta * delta^t * u

-- Bounded rationality
type BoundedRational = {
  computationLimit : Nat,          -- Limited cognitive resources
  satisfice : Utility → Bool,      -- Good enough threshold
  heuristics : List Heuristic      -- Mental shortcuts
}

-- ============================================================================
-- PART IX: COMPUTATIONAL ECONOMICS
-- ============================================================================

-- Market as computation
type MarketComputation (goods : Nat) (agents : Nat) = {
  endowments : Matrix Float agents goods,
  utilities : Vec (Vec Float goods → Utility) agents,
  compute : () → WalrasianEquilibrium
}

-- Tatonnement: Price adjustment process
tatonnement : Market g → Stream Price
tatonnement m = iterate adjust m.equilibrium.price
  where adjust p = p + α * (m.demand p - m.supply p)

-- Complexity of equilibrium computation
-- PPAD-complete for Arrow-Debreu economies
equilibriumComplexity : Complexity
equilibriumComplexity = PPAD  -- Polynomial Parity Argument on Directed graphs

-- Agent-based modeling
type ABM (n : Nat) = {
  agents : Vec EconomicAgent n,
  market : Market,
  step : ABM n → ABM n,
  emergentBehavior : ABM n → Observation
}

type EconomicAgent = Actor {
  wealth : Float,
  strategy : Strategy,
  beliefs : Beliefs,
  learn : Observation → Beliefs
}

-- ============================================================================
-- PART X: COMPILE TARGETS
-- ============================================================================

-- Economic models compile to simulations:

compile[Simulation] : Game → MonteCarlo Equilibrium
  -- Nash equilibrium computation
  -- Fictitious play
  -- Replicator dynamics

compile[Auction] : Auction → AuctionPlatform
  -- Real-time bidding systems
  -- Smart contract deployment
  -- Market maker algorithms

compile[Matching] : MatchingMarket → Algorithm
  -- Gale-Shapley (stable marriage)
  -- Top trading cycles (house allocation)
  -- Deferred acceptance

compile[Blockchain] : Mechanism → SmartContract
  -- Solidity/Vyper output
  -- Formal verification
  -- Gas optimization

-- ============================================================================
-- EXAMPLE: Complete Auction System
-- ============================================================================

-- Ad auction (Google-style)
adAuction : VCG AdSlot Advertiser
adAuction = {
  outcome = λ bids → 
    let ranked = sortBy (λ (bid, quality) → bid * quality) bids
    assignSlots ranked,
  
  payment = λ i bids →
    -- Pay minimum to maintain position
    let nextBidder = bids[rank(i) + 1]
    nextBidder.bid * nextBidder.quality / bids[i].quality + ε
}

-- Properties verified at compile time:
-- 1. Truth-telling is dominant
-- 2. Revenue is maximized among IC mechanisms
-- 3. No individual can profitably deviate

-- ============================================================================
-- THE BOTTOM LINE
-- ============================================================================

-- Economics is computational game theory:
-- • Preferences are utility functions
-- • Markets are equilibrium solvers
-- • Mechanisms are designed incentives
-- • Auctions are revelation protocols
-- • Evolution is selection pressure

-- Phi makes the incentives explicit in types.
