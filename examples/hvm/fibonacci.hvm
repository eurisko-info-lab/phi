// =============================================================================
// HVM4 Example: Recursive Fibonacci
// =============================================================================
// The classic fib function, showing how recursion works in HVM.

// ---------------------------------------------------------------------------
// Recursive definition
// ---------------------------------------------------------------------------
// fib(0) = 0
// fib(1) = 1
// fib(n) = fib(n-1) + fib(n-2)

@fib = λn.
  λ{0: 0;                           // base case: fib(0) = 0
    λ{1: 1;                         // base case: fib(1) = 1
      ((@fib (n - 1)) + (@fib (n - 2)))  // recursive case
    }
  }

// ---------------------------------------------------------------------------
// Compute fib(10)
// ---------------------------------------------------------------------------
@main = (@fib 10)
// Result: 55

// ---------------------------------------------------------------------------
// HVM's advantage: Optimal memoization via sharing
// ---------------------------------------------------------------------------
// In naive evaluation, fib(n) has exponential time complexity because
// fib(n-2) is computed twice (once directly, once via fib(n-1)).
//
// HVM's interaction net representation can automatically share the
// result of fib(n-2) between both uses, effectively memoizing without
// explicit state. This is the power of "optimal reduction."
//
// The key mechanism:
// - When @fib is duplicated (to compute both fib(n-1) and fib(n-2)),
//   HVM creates DUP nodes that track the sharing
// - When both copies request the same subcomputation, they share
//   the result through SUP/DUP interactions
// - No hash table needed - sharing emerges from the graph structure

