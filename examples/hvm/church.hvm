// =============================================================================
// HVM4 Example: Church Numerals
// =============================================================================
// Classic lambda calculus encoding of natural numbers.
// Shows HVM's optimal evaluation of higher-order functions.

// ---------------------------------------------------------------------------
// Church numeral encoding
// ---------------------------------------------------------------------------
// A Church numeral n is: λf.λx.(f (f (f ... (f x)))) with n applications of f

@c0 = λf.λx.x              // zero: apply f zero times
@c1 = λf.λx.(f x)          // one: apply f once
@c2 = λf.λx.(f (f x))      // two: apply f twice
@c3 = λf.λx.(f (f (f x)))  // three: apply f thrice

// ---------------------------------------------------------------------------
// Church arithmetic
// ---------------------------------------------------------------------------

// Successor: add one more f application
@succ = λn.λf.λx.(f ((n f) x))

// Addition: m + n = apply f (m+n) times
@add = λm.λn.λf.λx.((m f) ((n f) x))

// Multiplication: m * n = apply (f^n) m times
@mul = λm.λn.λf.(m (n f))

// Exponentiation: m ^ n = apply m n times
@exp = λm.λn.(n m)

// ---------------------------------------------------------------------------
// Convert to integer for display
// ---------------------------------------------------------------------------
@toInt = λn.((n λx.(x + 1)) 0)

// ---------------------------------------------------------------------------
// Example: compute 2^2 = 4
// ---------------------------------------------------------------------------
@main = (@toInt ((@exp @c2) @c2))
// Result: 4

// ---------------------------------------------------------------------------
// Why this is special in HVM:
// ---------------------------------------------------------------------------
// The expression (@exp @c2 @c2) creates Church 4, but the intermediate
// computations are optimally shared. When @c2 duplicates its argument f,
// HVM tracks this with SUP/DUP nodes, ensuring no redundant work.
//
// In a naive evaluator, (2^2) might evaluate @c2 multiple times.
// HVM's interaction net representation guarantees each subterm is
// evaluated at most once, achieving "optimal" reduction.

