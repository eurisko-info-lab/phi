// =============================================================================
// Phi: The Meta-Language Spec (in Port syntax)
// =============================================================================
// This is the language used to define language specs themselves.
// Grammars are BIDIRECTIONAL: the same declaration handles both parsing
// and rendering, with attributes controlling formatting.
//
// Original: phi.phi (213 lines)
// Port version: phi.port

port Phi {

  // ==========================================================================
  // MODULE: Core
  // Core sorts and constructors for language specifications
  // ==========================================================================
  module Core {
    export *

    // ------------------------------------------------------------------------
    // Spec Structure
    // ------------------------------------------------------------------------
    record Spec {
      name: String,
      decls: [Decl]
    }

    // ------------------------------------------------------------------------
    // Declarations
    // ------------------------------------------------------------------------
    type Decl = SortDecl(name: String)
              | KindedSortDecl(name: String, kind: Kind)
              | ConstructorDecl(name: String, typ: Type)
              | GrammarDecl(name: String, rules: [SyntaxRule])
              | XformDecl(name: String, from: String, to: String)
              | RuleDecl(name: String, cases: [RuleCase])
              | ClassDecl(name: String, params: [TypeParam], members: [ClassMember])
              | InstanceDecl(name: String, typ: Type, members: [InstanceMember])

    // ------------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------------
    type Type = SortRef(name: String)
              | Arrow(from: Type, to: Type)
              | ListOf(elem: Type)
              | Product(left: Type, right: Type)
              | TypeApp(name: String, args: [Type])
              | TypeVar(name: String)
              | TypeCon(name: String, arity: Int)
              | Constrained(constraints: [Constraint], body: Type)
              | Forall(params: [TypeParam], body: Type)

    // ------------------------------------------------------------------------
    // Kinds (types of types)
    // ------------------------------------------------------------------------
    type Kind = KindStar
              | KindArrow(from: Kind, to: Kind)

    // ------------------------------------------------------------------------
    // Type Parameters & Constraints
    // ------------------------------------------------------------------------
    record TypeParam {
      name: String,
      kind: Kind
    }

    record Constraint {
      typeVar: String,
      typeclass: String
    }

    // ------------------------------------------------------------------------
    // Typeclass Members
    // ------------------------------------------------------------------------
    type ClassMember = MethodSig(name: String, typ: Type)

    type InstanceMember = MethodImpl(name: String, pattern: Pattern, body: Pattern)

    // ------------------------------------------------------------------------
    // Grammar Rules
    // ------------------------------------------------------------------------
    record SyntaxRule {
      tokens: [SyntaxToken],
      result: SyntaxArg
    }

    type SyntaxToken = Literal(text: String)
                     | NonTerm(name: String, modifier: String)

    type SyntaxArg = ArgRef(name: String)
                   | ArgLit(text: String)
                   | ArgStrLit(text: String)
                   | ArgWrap(wrapper: String, inner: SyntaxArg)
                   | ArgCon(name: String, args: [SyntaxArg])
                   | ArgHole

    // ------------------------------------------------------------------------
    // Transform Rules
    // ------------------------------------------------------------------------
    record Rule {
      name: String,
      cases: [RuleCase]
    }

    type RuleCase = Case(pattern: Pattern, result: Pattern)
                  | CaseGuarded(pattern: Pattern, guard: RuleGuard, result: Pattern)

    type RuleGuard = IsConstructor(varName: String, ctorName: String)
                   | Equals(left: Pattern, right: Pattern)

    // ------------------------------------------------------------------------
    // Meta-level Patterns
    // ------------------------------------------------------------------------
    type Pattern = PVar(name: String)
                 | PCon(name: String, args: [Pattern])
                 | PApp(func: Pattern, arg: Pattern)
                 | PSubst(body: Pattern, varName: String, replacement: Pattern)
  }

  // ==========================================================================
  // MODULE: Syntax
  // Bidirectional grammars: parse ↔ render via the same rules
  // Attributes control formatting (indent, newline, space)
  // ==========================================================================
  module Syntax {
    import Core

    // Formatting attributes for rendering
    attr indent : Int = 0           // Current indentation level
    attr newline : Bool = true      // Insert newline after
    attr space : String = " "       // Separator between tokens

    // ------------------------------------------------------------------------
    // Spec: language Name { decls }
    // ------------------------------------------------------------------------
    grammar spec {
      "language" name:IDENT "{" @indent(+2) decls:decl* @indent(-2) "}"
        ⇔ Spec(name, decls)
    }

    // ------------------------------------------------------------------------
    // Declarations
    // ------------------------------------------------------------------------
    grammar decl {
      @newline "sort" name:IDENT
        ⇔ SortDecl(name)

      @newline "sort" name:IDENT "[" "_"+ "]"
        ⇔ KindedSortDecl(name, inferKind(count("_")))

      @newline "constructor" name:IDENT ":" typ:type
        ⇔ ConstructorDecl(name, typ)

      @newline "grammar" name:IDENT "{" @indent(+2) rules:syntaxRule* @indent(-2) "}"
        ⇔ GrammarDecl(name, rules)

      @newline "xform" name:IDENT ":" from:IDENT "⇄" to:IDENT
        ⇔ XformDecl(name, from, to)

      @newline "rule" name:qualifiedName "{" @indent(+2) cases:ruleCase* @indent(-2) "}"
        ⇔ RuleDecl(name, cases)

      @newline "class" name:IDENT "[" params:typeParam,+ "]" "{" @indent(+2) members:classMember* @indent(-2) "}"
        ⇔ ClassDecl(name, params, members)

      @newline "instance" name:IDENT typ:type "{" @indent(+2) members:instanceMember* @indent(-2) "}"
        ⇔ InstanceDecl(name, typ, members)
    }

    // ------------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------------
    grammar type {
      name:IDENT
        ⇔ SortRef(name)

      from:typeAtom "→" to:type
        ⇔ Arrow(from, to)

      "List" "[" elem:type "]"
        ⇔ ListOf(elem)

      left:typeAtom "×" right:typeAtom
        ⇔ Product(left, right)

      name:IDENT "[" args:type,+ "]"
        ⇔ TypeApp(name, args)

      name:IDENT "[" "_"+ "]"
        ⇔ TypeCon(name, count("_"))

      "∀" "[" params:typeParam,+ "]" body:type
        ⇔ Forall(params, body)

      "[" constraints:constraint,+ "]" "⇒" body:type
        ⇔ Constrained(constraints, body)
    }

    grammar typeAtom {
      "(" t:type ")"  ⇔ t
      name:IDENT      ⇔ SortRef(name)
    }

    // ------------------------------------------------------------------------
    // Kinds
    // ------------------------------------------------------------------------
    grammar kind {
      "*"                       ⇔ KindStar
      from:kindAtom "→" to:kind ⇔ KindArrow(from, to)
    }

    grammar kindAtom {
      "(" k:kind ")"  ⇔ k
      "*"             ⇔ KindStar
    }

    // ------------------------------------------------------------------------
    // Type Parameters & Constraints
    // ------------------------------------------------------------------------
    grammar typeParam {
      name:IDENT ":" k:kind   ⇔ TypeParam(name, k)
      name:IDENT              ⇔ TypeParam(name, KindStar)
    }

    grammar constraint {
      typeVar:IDENT ":" typeclass:IDENT
        ⇔ Constraint(typeVar, typeclass)
    }

    // ------------------------------------------------------------------------
    // Class/Instance Members
    // ------------------------------------------------------------------------
    grammar classMember {
      @newline name:IDENT ":" typ:type
        ⇔ MethodSig(name, typ)
    }

    grammar instanceMember {
      @newline pattern:pattern "↦" result:pattern
        ⇔ MethodImpl("", pattern, result)
    }

    // ------------------------------------------------------------------------
    // Syntax Rules (meta-grammar)
    // ------------------------------------------------------------------------
    grammar syntaxRule {
      @newline tokens:syntaxToken+ "=>" result:syntaxArg
        ⇔ SyntaxRule(tokens, result)
    }

    grammar syntaxToken {
      str:STRING        ⇔ Literal(str)
      name:IDENT        ⇔ NonTerm(name, "")
      name:IDENT "*"    ⇔ NonTerm(name, "*")
      name:IDENT "+"    ⇔ NonTerm(name, "+")
      name:IDENT "?"    ⇔ NonTerm(name, "?")
    }

    grammar syntaxArg {
      name:IDENT                    ⇔ ArgRef(name)
      str:STRING                    ⇔ ArgStrLit(str)
      name:IDENT "(" args:syntaxArg,* ")"  ⇔ ArgCon(name, args)
      "?"                           ⇔ ArgHole
    }

    // ------------------------------------------------------------------------
    // Rule Cases
    // ------------------------------------------------------------------------
    grammar ruleCase {
      @newline pattern:pattern "↦" result:pattern
        ⇔ Case(pattern, result)

      @newline pattern:pattern "|" guard:guard "↦" result:pattern
        ⇔ CaseGuarded(pattern, guard, result)
    }

    grammar guard {
      varName:IDENT "is" ctorName:IDENT
        ⇔ IsConstructor(varName, ctorName)

      left:pattern "==" right:pattern
        ⇔ Equals(left, right)
    }

    // ------------------------------------------------------------------------
    // Patterns
    // ------------------------------------------------------------------------
    grammar pattern {
      name:IDENT                          ⇔ PVar(name)
      name:IDENT "(" args:pattern,* ")"   ⇔ PCon(name, args)
      func:patternAtom arg:patternAtom    ⇔ PApp(func, arg)
      body:pattern "[" var:IDENT ":=" repl:pattern "]"
        ⇔ PSubst(body, var, repl)
    }

    grammar patternAtom {
      "(" p:pattern ")"   ⇔ p
      name:IDENT          ⇔ PVar(name)
    }
  }

  // ==========================================================================
  // MODULE: Transform
  // Apply phi transformations
  // ==========================================================================
  module Transform {
    import Core

    // Apply a transformation rule to a pattern
    func applyRule(rule: Rule, input: Pattern): Option[Pattern] = match rule {
      Rule(name, cases) => tryCases(cases, input)
    }

    func tryCases(cases: [RuleCase], input: Pattern): Option[Pattern] = match cases {
      [] => None

      [Case(pat, result) | rest] =>
        match tryMatch(pat, input) {
          Some(bindings) => Some(substitute(result, bindings))
          None           => tryCases(rest, input)
        }

      [CaseGuarded(pat, guard, result) | rest] =>
        match tryMatch(pat, input) {
          Some(bindings) =>
            if evalGuard(guard, bindings)
            then Some(substitute(result, bindings))
            else tryCases(rest, input)
          None => tryCases(rest, input)
        }
    }

    func tryMatch(pattern: Pattern, value: Pattern): Option[Bindings] = match (pattern, value) {
      (PVar(name), _)              => Some(bind(name, value, emptyBindings))
      (PCon(n1, ps), PCon(n2, vs)) =>
        if eq(n1, n2) then tryMatchAll(ps, vs, emptyBindings) else None
      (PApp(f1, a1), PApp(f2, a2)) =>
        match tryMatch(f1, f2) {
          Some(b1) => match tryMatch(a1, a2) {
            Some(b2) => Some(merge(b1, b2))
            None     => None
          }
          None => None
        }
      _ => None
    }

    func tryMatchAll(pats: [Pattern], vals: [Pattern], acc: Bindings): Option[Bindings] =
      match (pats, vals) {
        ([], [])             => Some(acc)
        ([p | ps], [v | vs]) =>
          match tryMatch(p, v) {
            Some(b) => tryMatchAll(ps, vs, merge(acc, b))
            None    => None
          }
        _ => None
      }

    func substitute(pattern: Pattern, bindings: Bindings): Pattern = match pattern {
      PVar(name)         => lookup(name, bindings, PVar(name))
      PCon(name, args)   => PCon(name, map(\a -> substitute(a, bindings), args))
      PApp(func, arg)    => PApp(substitute(func, bindings), substitute(arg, bindings))
      PSubst(body, var, repl) =>
        substitute(body, bind(var, substitute(repl, bindings), bindings))
    }

    func evalGuard(guard: RuleGuard, bindings: Bindings): Bool = match guard {
      IsConstructor(varName, ctorName) =>
        match lookup(varName, bindings, PVar(varName)) {
          PCon(name, _) => eq(name, ctorName)
          _             => false
        }
      Equals(left, right) =>
        eq(substitute(left, bindings), substitute(right, bindings))
    }
  }
}
