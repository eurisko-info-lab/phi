// =============================================================================
// Meta: The Language of Interpreters (in Port syntax)
// =============================================================================
// Defines the semantic primitives for pattern matching, substitution,
// and evaluation. This is the "runtime" that phi2scala.phi targets.
//
// Grammars are BIDIRECTIONAL: parse ↔ render via same rules.
// Attributes control formatting.
//
// Original: meta.phi (281 lines)
// Port version: meta.port

port Meta {

  // ==========================================================================
  // MODULE: Core
  // Core semantic sorts and values
  // ==========================================================================
  module Core {
    export *

    // ------------------------------------------------------------------------
    // Values - The Universal AST
    // ------------------------------------------------------------------------
    type Val = VCon(name: String, args: [Val])    // Constructor application
             | VStr(s: String)                     // String literal
             | VInt(n: Int)                        // Integer literal
             | VList(elems: [Val])                 // List value
             | VClosure(param: String, body: Expr, env: Env)  // Closure

    // ------------------------------------------------------------------------
    // Environments
    // ------------------------------------------------------------------------
    type Env = EmptyEnv
             | Bind(name: String, value: Val, rest: Env)

    // ------------------------------------------------------------------------
    // Patterns
    // ------------------------------------------------------------------------
    type Pat = PVar(name: String)                  // Variable pattern
             | PCon(name: String, args: [Pat])     // Constructor pattern
             | PWild                                // Wildcard
             | PLit(value: Val)                     // Literal pattern

    // ------------------------------------------------------------------------
    // Expressions
    // ------------------------------------------------------------------------
    type Expr = EVar(name: String)                 // Variable reference
              | ECon(name: String, args: [Expr])   // Constructor call
              | EApp(func: Expr, arg: Expr)        // Application
              | ELam(param: String, body: Expr)    // Lambda
              | ELet(name: String, value: Expr, body: Expr)  // Let binding
              | EMatch(scrutinee: Expr, cases: [Expr])       // Pattern match
              | ECase(pattern: Pat, body: Expr)    // Case clause

    // ------------------------------------------------------------------------
    // Results
    // ------------------------------------------------------------------------
    type Result = ROk(value: Val, env: Env)        // Successful match
                | RFail                             // Match failure
  }

  // ==========================================================================
  // MODULE: Syntax
  // Bidirectional grammars for all types
  // ==========================================================================
  module Syntax {
    import Core

    // Formatting attributes
    attr indent : Int = 0
    attr sep : String = ", "

    // ------------------------------------------------------------------------
    // Values
    // ------------------------------------------------------------------------
    grammar val {
      name:IDENT "(" @sep(", ") args:val,* ")"
        ⇔ VCon(name, args)

      name:IDENT
        ⇔ VCon(name, [])

      s:STRING
        ⇔ VStr(s)

      n:INT
        ⇔ VInt(n)

      "[" @sep(", ") elems:val,* "]"
        ⇔ VList(elems)
    }

    // ------------------------------------------------------------------------
    // Patterns
    // ------------------------------------------------------------------------
    grammar pat {
      name:IDENT "(" @sep(", ") args:pat,* ")"
        ⇔ PCon(name, args)

      "_"
        ⇔ PWild

      s:STRING
        ⇔ PLit(VStr(s))

      n:INT
        ⇔ PLit(VInt(n))

      name:IDENT
        ⇔ PVar(name)
    }

    // ------------------------------------------------------------------------
    // Expressions
    // ------------------------------------------------------------------------
    grammar expr {
      name:IDENT "(" @sep(", ") args:expr,* ")"
        ⇔ ECon(name, args)

      "λ" param:IDENT "." @space body:expr
        ⇔ ELam(param, body)

      "\\" param:IDENT "->" @space body:expr
        ⇔ ELam(param, body)

      "let" name:IDENT "=" value:expr "in" @space body:expr
        ⇔ ELet(name, value, body)

      "match" scrutinee:expr "{" @indent(+2) cases:case* @indent(-2) "}"
        ⇔ EMatch(scrutinee, cases)

      "(" func:expr @space arg:expr ")"
        ⇔ EApp(func, arg)

      name:IDENT
        ⇔ EVar(name)
    }

    grammar case {
      @newline pat:pat "=>" body:expr
        ⇔ ECase(pat, body)
    }

    // ------------------------------------------------------------------------
    // Environments (for debugging/display)
    // ------------------------------------------------------------------------
    grammar env {
      "{}"
        ⇔ EmptyEnv

      "{" name:IDENT "→" value:val rest:envRest "}"
        ⇔ Bind(name, value, rest)
    }

    grammar envRest {
      ""
        ⇔ EmptyEnv

      "," @space name:IDENT "→" value:val rest:envRest
        ⇔ Bind(name, value, rest)
    }

    // ------------------------------------------------------------------------
    // Results
    // ------------------------------------------------------------------------
    grammar result {
      "ROk" "(" v:val "," @space e:env ")"
        ⇔ ROk(v, e)

      "RFail"
        ⇔ RFail
    }
  }

  // ==========================================================================
  // MODULE: Match
  // Pattern matching implementation
  // ==========================================================================
  module Match {
    import Core

    // Match a pattern against a value in an environment
    xform match : (Pat, Val, Env) ⇄ Result {
      // Variable matches anything, binds it
      (PVar(name), val, env)
        ⇔ ROk(val, Bind(name, val, env))

      // Constructor matches if names equal and args match
      (PCon(name, pats), VCon(vname, args), env)
        | eq(name, vname)
        ⇔ matchArgs(pats, args, env)

      // Wildcard matches anything, binds nothing
      (PWild, val, env)
        ⇔ ROk(val, env)

      // Literal matches if equal
      (PLit(expected), val, env)
        | valEq(expected, val)
        ⇔ ROk(val, env)

      // Otherwise fail
      (_, _, _)
        ⇔ RFail
    }

    // Match multiple patterns against multiple values
    xform matchArgs : ([Pat], [Val], Env) ⇄ Result {
      ([], [], env)
        ⇔ ROk(VCon("Unit", []), env)

      ([p | ps], [v | vs], env)
        ⇔ match match(p, v, env) {
            ROk(_, env') => matchArgs(ps, vs, env')
            RFail        => RFail
          }

      (_, _, _)
        ⇔ RFail
    }

    // Value equality
    xform valEq : (Val, Val) ⇄ Bool {
      (VInt(n1), VInt(n2))             ⇔ eq(n1, n2)
      (VStr(s1), VStr(s2))             ⇔ eq(s1, s2)
      (VList(e1), VList(e2))           ⇔ listEq(e1, e2, valEq)
      (VCon(n1, a1), VCon(n2, a2))     ⇔ and(eq(n1, n2), listEq(a1, a2, valEq))
      (_, _)                           ⇔ false
    }
  }

  // ==========================================================================
  // MODULE: Eval
  // Expression evaluation
  // ==========================================================================
  module Eval {
    import Core
    import Match

    // Evaluate an expression in an environment
    xform eval : (Expr, Env) ⇄ Val {
      // Variable lookup
      (EVar(name), env)
        ⇔ lookup(name, env)

      // Constructor: evaluate args, build value
      (ECon(name, args), env)
        ⇔ VCon(name, map(\e -> eval(e, env), args))

      // Application: evaluate both, apply
      (EApp(func, arg), env)
        ⇔ apply(eval(func, env), eval(arg, env))

      // Lambda: create closure
      (ELam(param, body), env)
        ⇔ VClosure(param, body, env)

      // Let binding: evaluate value, extend env, evaluate body
      (ELet(name, value, body), env)
        ⇔ let v = eval(value, env) in
          eval(body, Bind(name, v, env))

      // Match: evaluate scrutinee, try cases
      (EMatch(scrutinee, cases), env)
        ⇔ let sval = eval(scrutinee, env) in
          tryCases(sval, cases, env)

      // Case clause (shouldn't be evaluated directly)
      (ECase(_, _), _)
        ⇔ error("ECase evaluated directly")
    }

    // Apply a function value to an argument
    xform apply : (Val, Val) ⇄ Val {
      (VClosure(param, body, closureEnv), arg)
        ⇔ eval(body, Bind(param, arg, closureEnv))

      (_, _)
        ⇔ error("Cannot apply non-function")
    }

    // Try each case until one matches
    xform tryCases : (Val, [Expr], Env) ⇄ Val {
      (_, [], _)
        ⇔ error("Non-exhaustive pattern match")

      (scrutinee, [ECase(pat, body) | rest], env)
        ⇔ match match(pat, scrutinee, env) {
            ROk(_, matchEnv) => eval(body, matchEnv)
            RFail            => tryCases(scrutinee, rest, env)
          }

      (_, _, _)
        ⇔ error("Invalid case expression")
    }

    // Environment lookup
    xform lookup : (String, Env) ⇄ Val {
      (name, EmptyEnv)
        ⇔ error(concat("Unbound variable: ", name))

      (name, Bind(n, v, rest))
        | eq(n, name)
        ⇔ v

      (name, Bind(_, _, rest))
        ⇔ lookup(name, rest)
    }
  }

  // ==========================================================================
  // MODULE: Subst
  // Expression substitution (capture-avoiding)
  // ==========================================================================
  module Subst {
    import Core

    // Substitute all free occurrences of a variable with an expression
    xform subst : (Expr, String, Expr) ⇄ Expr {
      (EVar(name), varName, replacement)
        | eq(name, varName)
        ⇔ replacement

      (EVar(name), _, _)
        ⇔ EVar(name)

      (ECon(name, args), varName, replacement)
        ⇔ ECon(name, map(\e -> subst(e, varName, replacement), args))

      (EApp(func, arg), varName, replacement)
        ⇔ EApp(subst(func, varName, replacement),
               subst(arg, varName, replacement))

      // Lambda: don't substitute if shadowed
      (ELam(param, body), varName, _)
        | eq(param, varName)
        ⇔ ELam(param, body)

      (ELam(param, body), varName, replacement)
        ⇔ ELam(param, subst(body, varName, replacement))

      // Let: don't substitute in body if shadowed
      (ELet(name, value, body), varName, replacement)
        | eq(name, varName)
        ⇔ ELet(name, subst(value, varName, replacement), body)

      (ELet(name, value, body), varName, replacement)
        ⇔ ELet(name,
               subst(value, varName, replacement),
               subst(body, varName, replacement))

      // Match: substitute in scrutinee, handle shadowing in cases
      (EMatch(scrutinee, cases), varName, replacement)
        ⇔ EMatch(subst(scrutinee, varName, replacement),
                 map(\c -> substCase(c, varName, replacement), cases))

      // Case: don't substitute if pattern binds the variable
      (ECase(pattern, body), varName, _)
        | binds(pattern, varName)
        ⇔ ECase(pattern, body)

      (ECase(pattern, body), varName, replacement)
        ⇔ ECase(pattern, subst(body, varName, replacement))
    }

    // Helper for substituting in cases
    xform substCase : (Expr, String, Expr) ⇄ Expr {
      (ECase(pattern, body), varName, _)
        | binds(pattern, varName)
        ⇔ ECase(pattern, body)

      (ECase(pattern, body), varName, replacement)
        ⇔ ECase(pattern, subst(body, varName, replacement))

      (other, _, _)
        ⇔ other
    }

    // Check if a pattern binds a variable name
    xform binds : (Pat, String) ⇄ Bool {
      (PVar(name), varName)
        ⇔ eq(name, varName)

      (PCon(_, args), varName)
        ⇔ any(\p -> binds(p, varName), args)

      (PWild, _)
        ⇔ false

      (PLit(_), _)
        ⇔ false
    }
  }

  // ==========================================================================
  // MODULE: Examples
  // Example programs demonstrating eval round-trip
  // ==========================================================================
  module Examples {
    import Core
    import Syntax
    import Eval

    // Example 1: Identity function
    // Concrete syntax ⇔ AST ⇔ Value
    //
    //   (λx. x) 42
    //   ⇔ EApp(ELam("x", EVar("x")), ECon("42", []))
    //   ⇔ VInt(42)

    // Example 2: Let binding
    //
    //   let x = 1 in let y = 2 in x
    //   ⇔ ELet("x", ECon("1", []), ELet("y", ECon("2", []), EVar("x")))
    //   ⇔ VInt(1)

    // Example 3: Pattern matching
    //
    //   match Some(42) { None => 0; Some(x) => x }
    //   ⇔ EMatch(ECon("Some", [ECon("42", [])]),
    //            [ECase(PCon("None", []), ECon("0", [])),
    //             ECase(PCon("Some", [PVar("x")]), EVar("x"))])
    //   ⇔ VInt(42)

    // Example 4: Curried function application
    //
    //   (λx. λy. Pair(x, y)) 1 2
    //   ⇔ EApp(EApp(ELam("x", ELam("y", ECon("Pair", [EVar("x"), EVar("y")]))),
    //               ECon("1", [])),
    //          ECon("2", []))
    //   ⇔ VCon("Pair", [VCon("1", []), VCon("2", [])])

    // Round-trip property:
    //   For any expression e and environment env:
    //   parse(render(e)) = e
    //   render(parse(s)) = s (modulo whitespace normalization)
  }
}
