package phi.user

import java.nio.file.{Files, Paths}
import phi.meta.*
import phi.meta.Val.*
import phi.phi.*

/**
 * GenHello: Demonstrates the bootstrapping pipeline
 * 
 * 1. Parse hello.phi (language spec) 
 * 2. Parse hello2scala.phi (transform spec)
 * 3. Use grammar to parse "Hello World" → AST
 * 4. Apply transforms → Scala AST
 * 5. Render Scala code
 */
object GenHello:

  def main(args: Array[String]): Unit =
    println("=" * 60)
    println("GenHello: Bootstrapping Pipeline Demo")
    println("=" * 60)
    
    // 1. Load and parse the language specs
    val helloSrc = Files.readString(Paths.get("examples/hello.phi"))
    val xformSrc = Files.readString(Paths.get("examples/hello2scala.phi"))
    
    println("\n[1] Parsing hello.phi...")
    val helloSpec = PhiParser.parseSpec(helloSrc) match
      case Right(spec) => 
        println(s"    ✓ Language: ${spec.name}")
        println(s"    ✓ Sorts: ${spec.sorts.map(_.name).mkString(", ")}")
        println(s"    ✓ Constructors: ${spec.constructors.map(_.name).mkString(", ")}")
        spec
      case Left(err) => 
        println(s"    ✗ Parse error: $err")
        return
    
    println("\n[2] Parsing hello2scala.phi...")
    val xformSpec = PhiParser.parseSpec(xformSrc) match
      case Right(spec) =>
        println(s"    ✓ Language: ${spec.name}")
        println(s"    ✓ Xforms: ${spec.xforms.map(_.name).mkString(", ")}")
        spec
      case Left(err) =>
        println(s"    ✗ Parse error: $err")
        return
    
    // 2. Build a parser from the grammar and parse input
    println("\n[3] Building parser from grammar 'greeting'...")
    val parser = GrammarInterp.specParser(helloSpec)
    
    val input = "Hello World"
    println(s"\n[4] Parsing: \"$input\"")
    val ast = parser.parse("greeting", input) match
      case Right(v) =>
        println(s"    ✓ AST: ${v.show}")
        v
      case Left(err) =>
        println(s"    ✗ Parse error: $err")
        return
    
    // 3. Apply transforms
    println("\n[5] Applying Greeting2Scala transform...")
    val interp = LangInterpreter(xformSpec)
    val scalaAst = interp.applyXform("Greeting2Scala", ast) match
      case Some(v) =>
        println(s"    ✓ Scala AST: ${v.show}")
        v
      case None =>
        println("    ✗ Transform failed")
        return
    
    // 4. Render Scala code
    println("\n[6] Rendering Scala code...")
    val scalaCode = renderScala(scalaAst)
    println(s"    ✓ Generated:\n$scalaCode")
    
    // 5. Write output
    val outputDir = Paths.get("tmp")
    if !Files.exists(outputDir) then Files.createDirectories(outputDir)
    val outputPath = outputDir.resolve("Hello.scala")
    
    val fullCode = s"""// Generated by GenHello
$scalaCode
"""
    Files.writeString(outputPath, fullCode)
    println(s"\n[7] Written to: $outputPath")
    
    println("\n" + "=" * 60)
    println("Pipeline complete!")
    println("=" * 60)

  /** Simple Scala renderer for our mini AST */
  def renderScala(v: Val, indent: Int = 0): String = 
    val pad = "  " * indent
    v match
      case VCon("ScalaObject", List(name, body)) =>
        s"object ${extractString(name)}:\n${renderScala(body, indent + 1)}"
      
      case VCon("MainDef", List(stmt)) =>
        s"${pad}def main(args: Array[String]): Unit =\n${renderScala(stmt, indent + 1)}"
      
      case VCon("PrintLn", List(expr)) =>
        s"${pad}println(${renderScala(expr)})"
      
      case VCon("StringLit", List(VCon("String", List(VCon(s, Nil))))) =>
        s"\"$s\""
      
      case VCon("StringLit", List(VCon(s, Nil))) =>
        s"\"$s\""
      
      case VCon("StringConcat", List(left, right)) =>
        s"${renderScala(left)} + ${renderScala(right)}"
      
      case VCon(name, Nil) =>
        name
      
      case VCon(name, args) =>
        s"$name(${args.map(renderScala(_)).mkString(", ")})"
      
      case VStr(s) => s"\"$s\""
      case VInt(n) => n.toString
      case VList(elems) => s"List(${elems.map(renderScala(_)).mkString(", ")})"
  
  def extractString(v: Val): String = v match
    case VCon("StringLit", List(VCon("String", List(VCon(s, Nil))))) => s
    case VCon("StringLit", List(VCon(s, Nil))) => s
    case VCon(s, Nil) => s
    case _ => v.show
