// =============================================================================
// PortVM: A Stack-Based Virtual Machine for Port/Phi
// =============================================================================
// A simple, efficient VM for executing Port programs.
// Stack-based design inspired by Forth, CAM (Categorical Abstract Machine),
// and the SECD machine, but simplified for clarity.
//
// Design principles:
// 1. Stack-based: operands on stack, results pushed back
// 2. Closures: functions capture their environment
// 3. Algebraic: constructors and pattern matching are first-class
// 4. Tail-call optimized: proper tail recursion
// 5. Self-describing: VM spec written in Port

port PortVM {

  // ==========================================================================
  // MODULE: Core
  // Core types for the VM
  // ==========================================================================
  module Core {
    export *

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------
    type Instr =
      // Stack operations
      | Push(val: Val)              // Push literal value onto stack
      | Pop                         // Discard top of stack
      | Dup                         // Duplicate top of stack
      | Swap                        // Swap top two stack elements
      | Rot                         // Rotate top three: a b c → b c a

      // Environment operations
      | Load(idx: Int)              // Push env[idx] onto stack
      | LoadName(name: String)      // Push env[name] onto stack (debug mode)
      | Store(idx: Int)             // Pop and store in env[idx]
      | PushEnv                     // Save current env to env stack
      | PopEnv                      // Restore env from env stack
      | ExtendEnv(n: Int)           // Extend env with n slots

      // Arithmetic (operate on stack)
      | Add | Sub | Mul | Div | Mod
      | Neg                         // Negate top of stack
      | Eq | Lt | Gt | Le | Ge | Ne // Comparisons → push Bool

      // Logic
      | And | Or | Not

      // String operations
      | Concat                      // Concatenate two strings
      | Length                      // String/list length

      // Control flow
      | Jump(offset: Int)           // Unconditional jump
      | JumpIf(offset: Int)         // Jump if top of stack is true
      | JumpIfNot(offset: Int)      // Jump if top of stack is false
      | Call(arity: Int)            // Call function with n args
      | TailCall(arity: Int)        // Tail call (reuse frame)
      | Return                      // Return from function
      | Halt                        // Stop execution

      // Closures
      | MakeClosure(code: Int, arity: Int)  // Create closure from code addr
      | Apply                       // Apply closure to arg on stack
      | PartialApply(n: Int)        // Partial application with n args

      // Constructors and pattern matching
      | MakeCon(tag: Int, arity: Int)       // Build constructor value
      | MakeConNamed(name: String, arity: Int)  // Build constructor by name
      | Untag                       // Push constructor tag
      | GetField(idx: Int)          // Push constructor field
      | Match(table: [MatchEntry])  // Pattern match dispatch

      // Lists (built-in for efficiency)
      | MakeList(n: Int)            // Build list from n stack elements
      | Cons                        // Push head onto list
      | Head                        // Extract list head
      | Tail                        // Extract list tail
      | IsEmpty                     // Check if list is empty

      // Tuples
      | MakeTuple(n: Int)           // Build tuple from n elements
      | GetTupleField(idx: Int)     // Extract tuple field

      // Debugging
      | Trace(msg: String)          // Print debug message
      | DumpStack                   // Print current stack
      | Breakpoint                  // Pause execution

    // Match table entry: tag → code offset
    record MatchEntry {
      tag: Int,
      offset: Int
    }

    // ------------------------------------------------------------------------
    // Values (runtime representation)
    // ------------------------------------------------------------------------
    type Val =
      | VInt(n: Int)
      | VStr(s: String)
      | VBool(b: Bool)
      | VList(elems: [Val])
      | VTuple(elems: [Val])
      | VCon(tag: Int, name: String, fields: [Val])
      | VClosure(code: Int, arity: Int, env: Env, applied: [Val])
      | VBuiltin(name: String)
      | VUnit
      | VNil                        // Empty/uninitialized

    // ------------------------------------------------------------------------
    // Environment (lexical scope)
    // ------------------------------------------------------------------------
    type Env = Env(slots: [Val], parent: Option[Env])

    // ------------------------------------------------------------------------
    // VM State
    // ------------------------------------------------------------------------
    record VMState {
      stack: [Val],                 // Operand stack
      env: Env,                     // Current environment
      envStack: [Env],              // Saved environments
      code: [Instr],                // Program code
      pc: Int,                      // Program counter
      callStack: [Frame],           // Call stack for returns
      status: Status                // Running, halted, error
    }

    record Frame {
      returnAddr: Int,              // Where to return to
      savedEnv: Env                 // Environment to restore
    }

    type Status =
      | Running
      | Halted(result: Val)
      | Error(msg: String)
  }

  // ==========================================================================
  // MODULE: Syntax
  // Assembly language syntax for VM
  // ==========================================================================
  module Syntax {
    import Core

    // Formatting
    attr indent : Int = 0
    attr label : Bool = false

    // ------------------------------------------------------------------------
    // Program
    // ------------------------------------------------------------------------
    grammar program {
      instrs:instrLine*
        ⇔ instrs
    }

    grammar instrLine {
      @newline label:IDENT ":" instr:instr
        ⇔ Labeled(label, instr)

      @newline instr:instr
        ⇔ instr
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------
    grammar instr {
      "push" val:val           ⇔ Push(val)
      "pop"                    ⇔ Pop
      "dup"                    ⇔ Dup
      "swap"                   ⇔ Swap
      "rot"                    ⇔ Rot

      "load" idx:INT           ⇔ Load(idx)
      "load" name:IDENT        ⇔ LoadName(name)
      "store" idx:INT          ⇔ Store(idx)
      "pushenv"                ⇔ PushEnv
      "popenv"                 ⇔ PopEnv
      "extend" n:INT           ⇔ ExtendEnv(n)

      "add"                    ⇔ Add
      "sub"                    ⇔ Sub
      "mul"                    ⇔ Mul
      "div"                    ⇔ Div
      "mod"                    ⇔ Mod
      "neg"                    ⇔ Neg
      "eq"                     ⇔ Eq
      "lt"                     ⇔ Lt
      "gt"                     ⇔ Gt
      "le"                     ⇔ Le
      "ge"                     ⇔ Ge
      "ne"                     ⇔ Ne

      "and"                    ⇔ And
      "or"                     ⇔ Or
      "not"                    ⇔ Not

      "concat"                 ⇔ Concat
      "length"                 ⇔ Length

      "jump" offset:INT        ⇔ Jump(offset)
      "jumpif" offset:INT      ⇔ JumpIf(offset)
      "jumpifnot" offset:INT   ⇔ JumpIfNot(offset)
      "call" arity:INT         ⇔ Call(arity)
      "tailcall" arity:INT     ⇔ TailCall(arity)
      "ret"                    ⇔ Return
      "halt"                   ⇔ Halt

      "closure" addr:INT "/" arity:INT
        ⇔ MakeClosure(addr, arity)
      "apply"                  ⇔ Apply
      "papply" n:INT           ⇔ PartialApply(n)

      "mkcon" tag:INT "/" arity:INT
        ⇔ MakeCon(tag, arity)
      "mkcon" name:IDENT "/" arity:INT
        ⇔ MakeConNamed(name, arity)
      "untag"                  ⇔ Untag
      "getfield" idx:INT       ⇔ GetField(idx)
      "match" "{" entries:matchEntry,* "}"
        ⇔ Match(entries)

      "mklist" n:INT           ⇔ MakeList(n)
      "cons"                   ⇔ Cons
      "head"                   ⇔ Head
      "tail"                   ⇔ Tail
      "isempty"                ⇔ IsEmpty

      "mktuple" n:INT          ⇔ MakeTuple(n)
      "gettuple" idx:INT       ⇔ GetTupleField(idx)

      "trace" msg:STRING       ⇔ Trace(msg)
      "dumpstack"              ⇔ DumpStack
      "breakpoint"             ⇔ Breakpoint
    }

    grammar matchEntry {
      tag:INT "=>" offset:INT
        ⇔ MatchEntry(tag, offset)
    }

    // ------------------------------------------------------------------------
    // Values
    // ------------------------------------------------------------------------
    grammar val {
      n:INT                    ⇔ VInt(n)
      s:STRING                 ⇔ VStr(s)
      "true"                   ⇔ VBool(true)
      "false"                  ⇔ VBool(false)
      "()"                     ⇔ VUnit
      "nil"                    ⇔ VNil
      "[" elems:val,* "]"      ⇔ VList(elems)
      "(" elems:val,+ ")"      ⇔ VTuple(elems)
    }
  }

  // ==========================================================================
  // MODULE: Exec
  // VM execution engine
  // ==========================================================================
  module Exec {
    import Core

    // Initialize VM with code
    xform init : [Instr] ⇄ VMState {
      code ⇔ VMState(
        stack: [],
        env: Env([], None),
        envStack: [],
        code: code,
        pc: 0,
        callStack: [],
        status: Running
      )
    }

    // Execute one instruction
    xform step : VMState ⇄ VMState {
      // Fetch-decode-execute cycle
      (state @ VMState(stack, env, envStack, code, pc, callStack, Running))
        ⇔ let instr = nth(code, pc) in
          exec(instr, state)

      // Already halted or errored - no change
      (state) ⇔ state
    }

    // Execute until halt
    xform run : VMState ⇄ VMState {
      (state @ VMState(_, _, _, _, _, _, Running))
        ⇔ run(step(state))

      (state) ⇔ state
    }

    // Execute single instruction
    xform exec : (Instr, VMState) ⇄ VMState {

      // === Stack Operations ===

      (Push(val), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ VMState([val | stack], env, es, code, pc + 1, cs, Running)

      (Pop, VMState([_ | stack], env, es, code, pc, cs, Running))
        ⇔ VMState(stack, env, es, code, pc + 1, cs, Running)

      (Dup, VMState([v | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([v, v | stack], env, es, code, pc + 1, cs, Running)

      (Swap, VMState([a, b | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([b, a | stack], env, es, code, pc + 1, cs, Running)

      (Rot, VMState([a, b, c | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([b, c, a | stack], env, es, code, pc + 1, cs, Running)

      // === Environment Operations ===

      (Load(idx), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let val = envLookup(env, idx) in
          VMState([val | stack], env, es, code, pc + 1, cs, Running)

      (Store(idx), VMState([val | stack], env, es, code, pc, cs, Running))
        ⇔ let env' = envStore(env, idx, val) in
          VMState(stack, env', es, code, pc + 1, cs, Running)

      (PushEnv, VMState(stack, env, es, code, pc, cs, Running))
        ⇔ VMState(stack, env, [env | es], code, pc + 1, cs, Running)

      (PopEnv, VMState(stack, _, [env | es], code, pc, cs, Running))
        ⇔ VMState(stack, env, es, code, pc + 1, cs, Running)

      (ExtendEnv(n), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let env' = Env(replicate(n, VNil), Some(env)) in
          VMState(stack, env', es, code, pc + 1, cs, Running)

      // === Arithmetic ===

      (Add, VMState([VInt(b), VInt(a) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VInt(a + b) | stack], env, es, code, pc + 1, cs, Running)

      (Sub, VMState([VInt(b), VInt(a) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VInt(a - b) | stack], env, es, code, pc + 1, cs, Running)

      (Mul, VMState([VInt(b), VInt(a) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VInt(a * b) | stack], env, es, code, pc + 1, cs, Running)

      (Div, VMState([VInt(b), VInt(a) | stack], env, es, code, pc, cs, Running))
        | ne(b, 0)
        ⇔ VMState([VInt(a / b) | stack], env, es, code, pc + 1, cs, Running)

      (Mod, VMState([VInt(b), VInt(a) | stack], env, es, code, pc, cs, Running))
        | ne(b, 0)
        ⇔ VMState([VInt(a % b) | stack], env, es, code, pc + 1, cs, Running)

      (Neg, VMState([VInt(n) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VInt(-n) | stack], env, es, code, pc + 1, cs, Running)

      // === Comparisons ===

      (Eq, VMState([b, a | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VBool(valEq(a, b)) | stack], env, es, code, pc + 1, cs, Running)

      (Lt, VMState([VInt(b), VInt(a) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VBool(a < b) | stack], env, es, code, pc + 1, cs, Running)

      (Gt, VMState([VInt(b), VInt(a) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VBool(a > b) | stack], env, es, code, pc + 1, cs, Running)

      // === Logic ===

      (And, VMState([VBool(b), VBool(a) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VBool(a && b) | stack], env, es, code, pc + 1, cs, Running)

      (Or, VMState([VBool(b), VBool(a) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VBool(a || b) | stack], env, es, code, pc + 1, cs, Running)

      (Not, VMState([VBool(b) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VBool(!b) | stack], env, es, code, pc + 1, cs, Running)

      // === String ===

      (Concat, VMState([VStr(b), VStr(a) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VStr(a ++ b) | stack], env, es, code, pc + 1, cs, Running)

      (Length, VMState([VStr(s) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VInt(strlen(s)) | stack], env, es, code, pc + 1, cs, Running)

      (Length, VMState([VList(l) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VInt(len(l)) | stack], env, es, code, pc + 1, cs, Running)

      // === Control Flow ===

      (Jump(offset), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ VMState(stack, env, es, code, pc + offset, cs, Running)

      (JumpIf(offset), VMState([VBool(true) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState(stack, env, es, code, pc + offset, cs, Running)

      (JumpIf(_), VMState([VBool(false) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState(stack, env, es, code, pc + 1, cs, Running)

      (JumpIfNot(offset), VMState([VBool(false) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState(stack, env, es, code, pc + offset, cs, Running)

      (JumpIfNot(_), VMState([VBool(true) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState(stack, env, es, code, pc + 1, cs, Running)

      (Call(arity), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let (args, [VClosure(addr, _, closureEnv, applied) | rest]) = splitAt(arity, stack) in
          let frame = Frame(pc + 1, env) in
          let newEnv = extendWith(closureEnv, reverse(args) ++ applied) in
          VMState(rest, newEnv, es, code, addr, [frame | cs], Running)

      (TailCall(arity), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let (args, [VClosure(addr, _, closureEnv, applied) | rest]) = splitAt(arity, stack) in
          let newEnv = extendWith(closureEnv, reverse(args) ++ applied) in
          VMState(rest, newEnv, es, code, addr, cs, Running)  // Reuse frame!

      (Return, VMState([result | _], _, es, code, _, [Frame(retAddr, savedEnv) | cs], Running))
        ⇔ VMState([result], savedEnv, es, code, retAddr, cs, Running)

      (Return, VMState([result | _], _, _, _, _, [], Running))
        ⇔ VMState([result], Env([], None), [], [], 0, [], Halted(result))

      (Halt, VMState([result | _], _, _, _, _, _, Running))
        ⇔ VMState([result], Env([], None), [], [], 0, [], Halted(result))

      (Halt, VMState([], _, _, _, _, _, Running))
        ⇔ VMState([], Env([], None), [], [], 0, [], Halted(VUnit))

      // === Closures ===

      (MakeClosure(addr, arity), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let closure = VClosure(addr, arity, env, []) in
          VMState([closure | stack], env, es, code, pc + 1, cs, Running)

      (Apply, VMState([arg, VClosure(addr, arity, closureEnv, applied) | stack], env, es, code, pc, cs, Running))
        | arity == 1
        ⇔ let frame = Frame(pc + 1, env) in
          let newEnv = extendWith(closureEnv, [arg | applied]) in
          VMState(stack, newEnv, es, code, addr, [frame | cs], Running)

      (Apply, VMState([arg, VClosure(addr, arity, closureEnv, applied) | stack], env, es, code, pc, cs, Running))
        | arity > 1
        ⇔ let closure' = VClosure(addr, arity - 1, closureEnv, [arg | applied]) in
          VMState([closure' | stack], env, es, code, pc + 1, cs, Running)

      // === Constructors ===

      (MakeCon(tag, arity), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let (fields, rest) = splitAt(arity, stack) in
          let con = VCon(tag, "", reverse(fields)) in
          VMState([con | rest], env, es, code, pc + 1, cs, Running)

      (MakeConNamed(name, arity), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let (fields, rest) = splitAt(arity, stack) in
          let tag = nameToTag(name) in
          let con = VCon(tag, name, reverse(fields)) in
          VMState([con | rest], env, es, code, pc + 1, cs, Running)

      (Untag, VMState([VCon(tag, _, _) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VInt(tag) | stack], env, es, code, pc + 1, cs, Running)

      (GetField(idx), VMState([VCon(_, _, fields) | stack], env, es, code, pc, cs, Running))
        ⇔ let field = nth(fields, idx) in
          VMState([field | stack], env, es, code, pc + 1, cs, Running)

      (Match(table), VMState([VCon(tag, _, _) | _], env, es, code, pc, cs, Running))
        ⇔ let offset = lookupMatch(table, tag) in
          VMState(stack, env, es, code, pc + offset, cs, Running)

      // === Lists ===

      (MakeList(n), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let (elems, rest) = splitAt(n, stack) in
          VMState([VList(reverse(elems)) | rest], env, es, code, pc + 1, cs, Running)

      (Cons, VMState([VList(tail), head | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VList([head | tail]) | stack], env, es, code, pc + 1, cs, Running)

      (Head, VMState([VList([h | _]) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([h | stack], env, es, code, pc + 1, cs, Running)

      (Tail, VMState([VList([_ | t]) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VList(t) | stack], env, es, code, pc + 1, cs, Running)

      (IsEmpty, VMState([VList([]) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VBool(true) | stack], env, es, code, pc + 1, cs, Running)

      (IsEmpty, VMState([VList([_ | _]) | stack], env, es, code, pc, cs, Running))
        ⇔ VMState([VBool(false) | stack], env, es, code, pc + 1, cs, Running)

      // === Tuples ===

      (MakeTuple(n), VMState(stack, env, es, code, pc, cs, Running))
        ⇔ let (elems, rest) = splitAt(n, stack) in
          VMState([VTuple(reverse(elems)) | rest], env, es, code, pc + 1, cs, Running)

      (GetTupleField(idx), VMState([VTuple(elems) | stack], env, es, code, pc, cs, Running))
        ⇔ let elem = nth(elems, idx) in
          VMState([elem | stack], env, es, code, pc + 1, cs, Running)

      // === Error cases ===

      (instr, VMState(_, _, _, _, _, _, Running))
        ⇔ VMState([], Env([], None), [], [], 0, [], 
                  Error(concat("Invalid instruction or stack state: ", show(instr))))
    }

    // Helper: lookup in match table
    xform lookupMatch : ([MatchEntry], Int) ⇄ Int {
      ([MatchEntry(tag, offset) | _], t) | eq(tag, t) ⇔ offset
      ([_ | rest], t)                                 ⇔ lookupMatch(rest, t)
      ([], _)                                         ⇔ 1  // Default: next instruction
    }
  }

  // ==========================================================================
  // MODULE: Compile
  // Compile Port expressions to VM code
  // ==========================================================================
  module Compile {
    import Core
    import meta.Core as M

    // Compilation context
    record CompileCtx {
      locals: [(String, Int)],      // Variable → stack index
      nextLocal: Int,
      labelCounter: Int
    }

    // Compile expression to instructions
    xform compile : (M.Expr, CompileCtx) ⇄ [Instr] {

      // Integer literal
      (M.EInt(n), _)
        ⇔ [Push(VInt(n))]

      // String literal
      (M.EStr(s), _)
        ⇔ [Push(VStr(s))]

      // Boolean literal
      (M.EBool(b), _)
        ⇔ [Push(VBool(b))]

      // Variable reference
      (M.EVar(name), ctx)
        ⇔ match lookup(name, ctx.locals) {
            Some(idx) => [Load(idx)]
            None      => [LoadName(name)]  // Global or builtin
          }

      // Constructor application
      (M.ECon(name, args), ctx)
        ⇔ let argCode = concat(map(\a -> compile(a, ctx), args)) in
          argCode ++ [MakeConNamed(name, length(args))]

      // Lambda: create closure
      (M.ELam(param, body), ctx)
        ⇔ let bodyCtx = addLocal(param, ctx) in
          let bodyCode = compile(body, bodyCtx) ++ [Return] in
          let closureAddr = allocCode(bodyCode) in
          [MakeClosure(closureAddr, 1)]

      // Application
      (M.EApp(func, arg), ctx)
        ⇔ compile(func, ctx) ++ compile(arg, ctx) ++ [Apply]

      // Let binding
      (M.ELet(name, value, body), ctx)
        ⇔ let valueCode = compile(value, ctx) in
          let bodyCtx = addLocal(name, ctx) in
          let bodyCode = compile(body, bodyCtx) in
          [ExtendEnv(1)] ++ valueCode ++ [Store(0)] ++ bodyCode ++ [PopEnv]

      // Pattern match
      (M.EMatch(scrutinee, cases), ctx)
        ⇔ let scrutCode = compile(scrutinee, ctx) in
          let (table, caseCode) = compileCases(cases, ctx) in
          scrutCode ++ [Match(table)] ++ caseCode

      // Primitives
      (M.EPrim("+", [a, b]), ctx)
        ⇔ compile(a, ctx) ++ compile(b, ctx) ++ [Add]

      (M.EPrim("-", [a, b]), ctx)
        ⇔ compile(a, ctx) ++ compile(b, ctx) ++ [Sub]

      (M.EPrim("*", [a, b]), ctx)
        ⇔ compile(a, ctx) ++ compile(b, ctx) ++ [Mul]

      (M.EPrim("==", [a, b]), ctx)
        ⇔ compile(a, ctx) ++ compile(b, ctx) ++ [Eq]

      (M.EPrim("<", [a, b]), ctx)
        ⇔ compile(a, ctx) ++ compile(b, ctx) ++ [Lt]

      // If-then-else (desugared from match on Bool)
      (M.EIf(cond, thenE, elseE), ctx)
        ⇔ let condCode = compile(cond, ctx) in
          let thenCode = compile(thenE, ctx) in
          let elseCode = compile(elseE, ctx) in
          let thenLen = length(thenCode) + 1 in  // +1 for jump over else
          let elseLen = length(elseCode) in
          condCode ++ [JumpIfNot(thenLen + 1)] ++ thenCode ++ [Jump(elseLen + 1)] ++ elseCode

      // List literal
      (M.EList(elems), ctx)
        ⇔ let elemCode = concat(map(\e -> compile(e, ctx), elems)) in
          elemCode ++ [MakeList(length(elems))]
    }

    // Add local variable to context
    xform addLocal : (String, CompileCtx) ⇄ CompileCtx {
      (name, CompileCtx(locals, next, lc))
        ⇔ CompileCtx([(name, next) | locals], next + 1, lc)
    }
  }

  // ==========================================================================
  // MODULE: Examples
  // Example programs in VM assembly
  // ==========================================================================
  module Examples {
    import Core
    import Syntax

    // Example 1: Factorial
    //   func fact(n) = if n <= 1 then 1 else n * fact(n - 1)
    //
    // fact:
    //   load 0          ; n
    //   push 1
    //   le
    //   jumpifnot 3     ; skip to recursive case
    //   push 1
    //   ret
    //   load 0          ; n
    //   load 0          ; n
    //   push 1
    //   sub             ; n - 1
    //   closure fact/1
    //   apply           ; fact(n-1)
    //   mul             ; n * fact(n-1)
    //   ret

    // Example 2: Map over list
    //   func map(f, xs) = match xs {
    //     [] => []
    //     [h | t] => [f(h) | map(f, t)]
    //   }
    //
    // map:
    //   load 1          ; xs
    //   isempty
    //   jumpifnot 3
    //   mklist 0        ; []
    //   ret
    //   load 1          ; xs
    //   head            ; h
    //   load 0          ; f
    //   apply           ; f(h)
    //   load 1          ; xs
    //   tail            ; t
    //   load 0          ; f
    //   closure map/2
    //   apply           ; partial: map(f)
    //   apply           ; map(f, t)
    //   cons            ; [f(h) | map(f, t)]
    //   ret

    // Example 3: Fibonacci with tail recursion
    //   func fib(n) = fibAux(n, 0, 1)
    //   func fibAux(n, a, b) = if n == 0 then a else fibAux(n-1, b, a+b)
    //
    // fib:
    //   load 0          ; n
    //   push 0          ; a = 0
    //   push 1          ; b = 1
    //   closure fibAux/3
    //   tailcall 3
    //
    // fibAux:
    //   load 0          ; n
    //   push 0
    //   eq
    //   jumpifnot 3
    //   load 1          ; a
    //   ret
    //   load 0          ; n
    //   push 1
    //   sub             ; n - 1
    //   load 2          ; b
    //   load 1          ; a
    //   load 2          ; b
    //   add             ; a + b
    //   closure fibAux/3
    //   tailcall 3      ; TCO: reuse stack frame
  }
}
