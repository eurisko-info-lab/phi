# Phi Hello World - Bootstrapping Demo

This is a minimal standalone demonstration of the **Phi bootstrapping concept**:
a language that can define languages, including itself.

## Overview

The Hello World demo shows the complete pipeline:

```
hello.phi          →  Parse "Hello World"  →  Hello(SimpleName("World"))
                              ↓
hello2scala.phi    →  Transform AST        →  ScalaObject(MainDef(PrintLn(...)))
                              ↓
scala.phi          →  Render Scala code    →  object Hello { def main... }
```

## Language Specs

### 1. `phi.phi` - The Meta-Language
Defines the syntax for writing `.phi` files themselves. This is the foundation
for bootstrapping - the language that describes languages.

**Key constructs:**
- `language Name { ... }` - Define a language spec
- `sort Name` - Declare a type/sort
- `constructor Name : Type → Type` - Declare a constructor
- `grammar name { pattern => Result }` - Define parsing rules
- `xform Name : Source ⇄ Target` - Declare a bidirectional transform
- `rule Name.case { pattern ↦ result }` - Define transform rules

### 2. `meta.phi` - The Interpreter Language
Defines the semantic primitives: Val, Env, Pat, Expr, Result.
This is the "runtime" - what values look like and how matching/evaluation work.

**Key constructs:**
- `Val` - Runtime values (VCon, VStr, VInt, VList)
- `Env` - Variable bindings
- `Pat` - Patterns for matching (PVar, PCon, PWild)
- `Expr` - Expressions (EVar, ECon, EApp, ELam, EMatch)
- `Match`, `Eval`, `Subst` - Core operations

### 3. `meta2scala.phi` - Interpreter to Scala
Compiles the meta-level definitions into executable Scala code.

### 4. `phi2scala.phi` - Spec Compiler
Transforms any `.phi` spec into a Scala implementation.
This generates parsers, interpreters, etc. from language definitions.

### 5. `hello.phi` - Source Language
A tiny language with just one construct: `Hello <name>`

```
language Hello {
  sort Greeting
  sort Name
  constructor Hello : Name → Greeting
  constructor SimpleName : String → Name
  grammar greeting { "Hello" IDENT => Hello(SimpleName(IDENT)) }
}
```

### 6. `scala.phi` - Target Language
Defines the Scala AST subset we generate:

```
language Scala {
  sort ScalaExpr; sort ScalaStmt; sort ScalaDecl; sort ScalaFile
  constructor ScalaObject : String → ScalaDecl → ScalaFile
  constructor MainDef : ScalaStmt → ScalaDecl
  constructor PrintLn : ScalaExpr → ScalaStmt
  constructor StringLit : String → ScalaExpr
  constructor StringConcat : ScalaExpr → ScalaExpr → ScalaExpr
}
```

### 7. `hello2scala.phi` - Transform Spec
Maps Hello AST to Scala AST:

```
rule Greeting2Scala.hello {
  Hello(name) ↦ ScalaObject(StringLit("Hello"), 
                  MainDef(PrintLn(StringConcat(StringLit("Hi, "), 
                          StringConcat(Name2Scala.forward(name), 
                                       StringLit("!"))))))
}
```

## Running the Demo

There are **two versions** in user/:

### 1. GenHello - Compiled Version

The rendering is "hardcoded" - this is what `hello2scala(hello.phi)` generates:

```bash
sbt "runMain phi.user.GenHello"
```

**Output:**
```
[4] Parsing: "Hello World"
    ✓ AST: Hello(SimpleName(String(World)))

[5] Applying Greeting2Scala transform...
    ✓ Scala AST: ScalaObject(StringLit(Hello), MainDef(PrintLn(...)))

[6] Rendering Scala code...
    ✓ Generated:
object Hello:
  def main(args: Array[String]): Unit =
    println("Hi, " + "World" + "!")
```

Generated file: `tmp/Hello.scala`

### 2. RunHello - Interpreted Version

Loads and executes the specs at runtime:

```bash
sbt "runMain phi.user.RunHello"
```

**Pipeline:**
1. Load `hello.phi`, `scala.phi`, `hello2scala.phi` at runtime
2. Parse input using `hello.phi` grammar
3. Transform using `hello2scala.phi` rules
4. Render using `scala.phi` grammar (bidirectional!)

This demonstrates **full interpretation** - no compilation, just specs!

## Project Structure

```
hello/
├── build.sbt                    # SBT build (Scala 3.7.4)
├── project/build.properties     # sbt.version=1.11.7
├── examples/
│   ├── phi.phi                  # Syntax: .phi file format
│   ├── meta.phi                 # Semantics: Val, Env, Pat, Expr
│   ├── phi2scala.phi            # Compiler: phi specs → Scala
│   ├── meta2scala.phi           # Compiler: meta interpreter → Scala
│   ├── hello.phi                # Demo source language
│   ├── scala.phi                # Demo target language  
│   └── hello2scala.phi          # Demo transform
├── src/main/scala/phi/
│   ├── meta/                    # Generated by: meta2scala(meta.phi)
│   │   ├── Val.scala            # Val, Env, Pat, Expr, Result types
│   │   ├── Core.scala           # Match, Eval operations
│   │   ├── Syntax.scala         # Bidirectional parsing
│   │   └── MetaInterp.scala     # Transform interpreter
│   ├── phi/                     # Generated by: phi2scala(phi.phi)
│   │   ├── LangSpec.scala       # Spec data types
│   │   ├── PhiParser.scala      # Parse .phi files
│   │   └── GrammarInterp.scala  # Grammar interpreter
│   └── user/                    # Generated by: hello2scala(hello.phi)
│       ├── GenHello.scala       # Compiled version (hardcoded rendering)
│       └── RunHello.scala       # Interpreted version (uses specs at runtime)
└── tmp/
    └── Hello.scala              # Output of running GenHello
```

## The Bootstrapping Concept

The key insight is that `phi.phi` uses the same constructs it defines:
- It declares `sort`, `constructor`, `grammar`, `xform`, `rule`
- Using the syntax: `sort Sort`, `constructor SortDecl : String → Decl`, etc.

This self-description is what makes Phi a **meta-language** - it can define
any language, including itself. The Hello World demo is the simplest possible
instance of this pattern.

### Bootstrap Equation

```
meta.phi ───────► meta2scala.phi ───────► phi/meta/*.scala
   │                                         (Val, Syntax, MetaInterp)
   │
phi.phi ────────► phi2scala.phi ────────► phi/phi/*.scala
   │                                         (LangSpec, PhiParser, GrammarInterp)
   │
hello.phi ──────► hello2scala.phi ──────► phi/user/*.scala
                                             (GenHello)
                         │
                         ▼
                  tmp/Hello.scala
                  (println("Hi, " + "World" + "!"))
```

The hand-written Scala in this project is what the `*2scala.phi` transforms
would generate. To bootstrap: implement the transforms, then regenerate!

### Portability

The `*2scala.phi` files are the **only target-specific part**. To port Phi to
another language, just rewrite the transforms:

```
*2scala.phi   → Scala implementation
*2haskell.phi → Haskell implementation  
*2rust.phi    → Rust implementation
*2ocaml.phi   → OCaml implementation
```

The source specs (`meta.phi`, `phi.phi`, `hello.phi`) remain unchanged.
This is the power of separating **what** (the specs) from **how** (the transforms).

## Minimal Implementation (~500 lines)

| File              | Lines | Purpose                          |
|-------------------|-------|----------------------------------|
| Val.scala         | ~70   | Val, Env, Pat, Expr, Result      |
| Core.scala        | ~100  | Match, Eval operations           |
| LangSpec.scala    | ~65   | Spec data types                  |
| PhiParser.scala   | ~120  | Parse .phi files                 |
| Syntax.scala      | ~140  | Bidirectional parsing primitives |
| GrammarInterp.scala| ~80  | Execute grammar rules            |
| MetaInterp.scala  | ~115  | Execute transform rules          |
| GenHello.scala    | ~90   | Compiled demo driver             |
| RunHello.scala    | ~130  | Interpreted demo driver          |

## Next Steps

To extend this demo:
1. Add more Hello constructs (e.g., `Goodbye`, `Question`)
2. Add more Scala constructs (e.g., `Val`, `If`, `Match`)
3. Make the renderer use the `scala.phi` grammar bidirectionally
4. **Bootstrap**: Apply `phi2scala.phi` + `meta2scala.phi` to generate the Scala implementation!
5. Verify the generated Scala can parse and run the original specs
