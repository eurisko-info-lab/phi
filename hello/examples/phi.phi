// =============================================================================
// Phi: The Meta-Language Spec
// =============================================================================
// This is the language used to define language specs themselves.
// It's the foundation for bootstrapping - phi.phi defines the syntax
// for writing .phi files like hello.phi, scala.phi, and hello2scala.phi.

language Phi {
  // ==========================================================================
  // Core Sorts
  // ==========================================================================
  sort Spec           // A complete language specification
  sort Decl           // Top-level declarations
  sort Sort           // Sort (type) declarations
  sort Constructor    // Constructor declarations
  sort Type           // Type expressions
  sort Grammar        // Grammar definitions
  sort SyntaxRule     // Individual grammar rules
  sort SyntaxToken    // Tokens in grammar patterns
  sort SyntaxArg      // Arguments in grammar results
  sort Xform          // Transform declarations
  sort Rule           // Transform rules
  sort Pattern        // Meta-level patterns

  // ==========================================================================
  // Spec Structure
  // ==========================================================================
  constructor LangSpec : String → List[Decl] → Spec

  // ==========================================================================
  // Declarations
  // ==========================================================================
  constructor SortDecl : String → Decl
  constructor ConstructorDecl : String → Type → Decl
  constructor GrammarDecl : String → List[SyntaxRule] → Decl
  constructor XformDecl : String → String → String → Decl
  constructor RuleDecl : String → List[Pattern] → Decl

  // ==========================================================================
  // Types
  // ==========================================================================
  constructor SortRef : String → Type
  constructor Arrow : Type → Type → Type

  // ==========================================================================
  // Grammar Rules
  // ==========================================================================
  constructor SynRule : List[SyntaxToken] → SyntaxArg → SyntaxRule
  
  // Tokens
  constructor Literal : String → SyntaxToken
  constructor NonTerm : String → SyntaxToken
  
  // Arguments
  constructor ArgRef : String → SyntaxArg
  constructor ArgCon : String → List[SyntaxArg] → SyntaxArg

  // ==========================================================================
  // Transform Patterns
  // ==========================================================================
  constructor PVar : String → Pattern
  constructor PCon : String → List[Pattern] → Pattern
  constructor PApp : Pattern → Pattern → Pattern
  constructor RuleCase : Pattern → Pattern → Rule

  // ==========================================================================
  // Grammar: Parse .phi files
  // ==========================================================================
  
  grammar spec {
    "language" IDENT "{" decl* "}" => LangSpec(IDENT, decl)
  }

  grammar decl {
    "sort" IDENT => SortDecl(IDENT)
    "constructor" IDENT ":" type => ConstructorDecl(IDENT, type)
    "grammar" IDENT "{" syntaxRule* "}" => GrammarDecl(IDENT, syntaxRule)
    "xform" IDENT ":" IDENT "⇄" IDENT => XformDecl(IDENT, IDENT, IDENT)
    "rule" qualifiedName "{" ruleCase "}" => RuleDecl(qualifiedName, ruleCase)
  }

  grammar type {
    IDENT => SortRef(IDENT)
    type "→" type => Arrow(type, type)
  }

  grammar syntaxRule {
    syntaxToken+ "=>" syntaxArg => SynRule(syntaxToken, syntaxArg)
  }

  grammar syntaxToken {
    STRING => Literal(STRING)
    IDENT => NonTerm(IDENT)
  }

  grammar syntaxArg {
    IDENT => ArgRef(IDENT)
    IDENT "(" syntaxArg* ")" => ArgCon(IDENT, syntaxArg)
  }

  grammar pattern {
    IDENT => PVar(IDENT)
    IDENT "(" pattern* ")" => PCon(IDENT, pattern)
  }

  grammar ruleCase {
    pattern "↦" pattern => RuleCase(pattern, pattern)
  }
}
