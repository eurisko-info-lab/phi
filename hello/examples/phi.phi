// =============================================================================
// Phi: The Meta-Language Spec
// =============================================================================
// This is the language used to define language specs themselves.
// It's the foundation for bootstrapping - phi.phi defines the syntax
// for writing .phi files like hello.phi, scala.phi, and hello2scala.phi.

language Phi {
  // ==========================================================================
  // Core Sorts
  // ==========================================================================
  sort Spec           // A complete language specification
  sort Decl           // Top-level declarations
  sort Sort           // Sort (type) declarations
  sort Constructor    // Constructor declarations
  sort Type           // Type expressions
  sort Grammar        // Grammar definitions
  sort SyntaxRule     // Individual grammar rules
  sort SyntaxToken    // Tokens in grammar patterns
  sort SyntaxArg      // Arguments in grammar results
  sort Xform          // Transform declarations
  sort Rule           // Transform rules
  sort RuleCase       // Individual rule case
  sort RuleGuard      // Guard conditions
  sort Pattern        // Meta-level patterns

  // ==========================================================================
  // Spec Structure
  // ==========================================================================
  constructor LangSpec : String → List[Decl] → Spec

  // ==========================================================================
  // Declarations
  // ==========================================================================
  constructor SortDecl : String → Decl
  constructor KindedSortDecl : String → Kind → Decl      // sort F[_] (kind * → *)
  constructor ConstructorDecl : String → Type → Decl
  constructor GrammarDecl : String → List[SyntaxRule] → Decl
  constructor XformDecl : String → String → String → Decl
  constructor RuleDecl : String → List[RuleCase] → Decl
  
  // Typeclass declarations
  constructor ClassDecl : String → List[TypeParam] → List[ClassMember] → Decl
  constructor InstanceDecl : String → Type → List[InstanceMember] → Decl
  
  // ==========================================================================
  // Typeclass Members
  // ==========================================================================
  sort ClassMember
  sort InstanceMember
  
  constructor MethodSig : String → Type → ClassMember           // method signature
  constructor MethodImpl : String → Pattern → Pattern → InstanceMember  // method implementation

  // ==========================================================================
  // Types
  // ==========================================================================
  constructor SortRef : String → Type
  constructor Arrow : Type → Type → Type
  constructor ListOf : Type → Type
  constructor Product : Type → Type → Type
  constructor TypeApp : String → List[Type] → Type
  constructor TypeVar : String → Type
  
  // Higher-kinded types: F[_], F[_, _], etc.
  constructor TypeCon : String → Int → Type              // Name, arity (F[_] = arity 1)
  constructor KindArrow : Kind → Kind → Kind             // * → * → *
  constructor KindStar : Kind                            // * (concrete type)
  
  // Typeclass constraints: [F: Functor], [M: Monad]
  constructor Constrained : List[Constraint] → Type → Type
  constructor Constraint : String → String → Constraint  // (TypeVar, Typeclass)
  
  // Forall: ∀F[_]. ∀A. F[A] → A
  constructor Forall : List[TypeParam] → Type → Type
  constructor TypeParam : String → Kind → TypeParam      // Name, kind
  
  // ==========================================================================
  // Kinds (types of types)
  // ==========================================================================
  sort Kind
  sort Constraint
  sort TypeParam

  // ==========================================================================
  // Grammar Rules
  // ==========================================================================
  constructor SynRule : List[SyntaxToken] → SyntaxArg → SyntaxRule
  
  // Tokens
  constructor Literal : String → SyntaxToken
  constructor NonTerm : String → String → SyntaxToken   // name, modifier (*, +, ?)
  
  // Arguments
  constructor ArgRef : String → SyntaxArg
  constructor ArgLit : String → SyntaxArg
  constructor ArgStrLit : String → SyntaxArg
  constructor ArgWrap : String → SyntaxArg → SyntaxArg
  constructor ArgCon : String → List[SyntaxArg] → SyntaxArg
  constructor ArgHole : SyntaxArg

  // ==========================================================================
  // Transform Rules
  // ==========================================================================
  constructor Rule : String → List[RuleCase] → Rule
  constructor Case : Pattern → Pattern → RuleCase
  constructor CaseGuarded : Pattern → RuleGuard → Pattern → RuleCase
  
  // Guards
  constructor IsConstructor : String → String → RuleGuard
  constructor Equals : Pattern → Pattern → RuleGuard

  // ==========================================================================
  // Meta-level Patterns
  // ==========================================================================
  constructor PVar : String → Pattern
  constructor PCon : String → List[Pattern] → Pattern
  constructor PApp : Pattern → Pattern → Pattern
  constructor PSubst : Pattern → String → Pattern → Pattern

  // ==========================================================================
  // Grammar: Parse .phi files
  // ==========================================================================
  
  grammar spec {
    "language" IDENT "{" decl* "}" => LangSpec(IDENT, decl)
  }

  grammar decl {
    "sort" IDENT => SortDecl(IDENT)
    "sort" IDENT "[" "_"+ "]" => KindedSortDecl(IDENT, _)        // sort F[_]
    "constructor" IDENT ":" type => ConstructorDecl(IDENT, type)
    "grammar" IDENT "{" syntaxRule* "}" => GrammarDecl(IDENT, syntaxRule)
    "xform" IDENT ":" IDENT "⇄" IDENT => XformDecl(IDENT, IDENT, IDENT)
    "rule" qualifiedName "{" ruleCase "}" => RuleDecl(qualifiedName, ruleCase)
    "class" IDENT "[" typeParam+ "]" "{" classMember* "}" => ClassDecl(IDENT, typeParam, classMember)
    "instance" IDENT type "{" instanceMember* "}" => InstanceDecl(IDENT, type, instanceMember)
  }
  
  // Qualified name: IDENT or IDENT.IDENT.IDENT...
  grammar qualifiedName {
    IDENT => IDENT
  }

  grammar type {
    IDENT => SortRef(IDENT)
    type "→" type => Arrow(type, type)
    "List" "[" type "]" => ListOf(type)
    type "×" type => Product(type, type)
    IDENT "[" "_"+ "]" => TypeCon(IDENT, _)             // F[_], M[_,_]
    "∀" "[" typeParam+ "]" type => Forall(typeParam, type)
    "[" constraint+ "]" "⇒" type => Constrained(constraint, type)
  }
  
  grammar typeParam {
    IDENT ":" kind => TypeParam(IDENT, kind)
    IDENT => TypeParam(IDENT, KindStar)
  }
  
  grammar kind {
    "*" => KindStar
    kind "→" kind => KindArrow(kind, kind)
    "(" kind ")" => kind
  }
  
  grammar constraint {
    IDENT ":" IDENT => Constraint(IDENT, IDENT)          // F: Functor
  }
  
  grammar classMember {
    IDENT ":" type => MethodSig(IDENT, type)            // map : (A → B) → F[A] → F[B]
  }
  
  grammar instanceMember {
    pattern "↦" pattern => MethodImpl("", pattern, pattern)   // method implementation
  }

  grammar syntaxRule {
    syntaxToken+ "=>" syntaxArg => SynRule(syntaxToken, syntaxArg)
  }

  grammar syntaxToken {
    STRING => Literal(STRING)
    IDENT => NonTerm(IDENT, "")
    IDENT "*" => NonTerm(IDENT, "*")
    IDENT "+" => NonTerm(IDENT, "+")
    IDENT "?" => NonTerm(IDENT, "?")
  }

  grammar syntaxArg {
    IDENT => ArgRef(IDENT)
    STRING => ArgStrLit(STRING)
    IDENT "(" syntaxArg* ")" => ArgCon(IDENT, syntaxArg)
    "?" => ArgHole
  }

  grammar ruleCase {
    pattern "↦" pattern => Case(pattern, pattern)
    pattern "|" guard "↦" pattern => CaseGuarded(pattern, guard, pattern)
  }

  grammar guard {
    IDENT "is" IDENT => IsConstructor(IDENT, IDENT)
    pattern "==" pattern => Equals(pattern, pattern)
  }

  grammar pattern {
    IDENT => PVar(IDENT)
    IDENT "(" pattern* ")" => PCon(IDENT, pattern)
    pattern pattern => PApp(pattern, pattern)
  }
}
