// =============================================================================
// Phi: The Meta-Language Spec
// =============================================================================
// This is the language used to define language specs themselves.
// It's the foundation for bootstrapping - phi.phi defines the syntax
// for writing .phi files like hello.phi, scala.phi, and hello2scala.phi.

language Phi {
  // ==========================================================================
  // Core Sorts
  // ==========================================================================
  sort Spec           // A complete language specification
  sort Decl           // Top-level declarations
  sort Sort           // Sort (type) declarations
  sort Constructor    // Constructor declarations
  sort Type           // Type expressions
  sort Grammar        // Grammar definitions
  sort SyntaxRule     // Individual grammar rules
  sort SyntaxToken    // Tokens in grammar patterns
  sort SyntaxArg      // Arguments in grammar results
  sort Xform          // Transform declarations
  sort Rule           // Transform rules
  sort RuleCase       // Individual rule case
  sort RuleGuard      // Guard conditions
  sort Pattern        // Meta-level patterns

  // ==========================================================================
  // Spec Structure
  // ==========================================================================
  constructor LangSpec : String → List[Decl] → Spec

  // ==========================================================================
  // Declarations
  // ==========================================================================
  constructor SortDecl : String → Decl
  constructor ConstructorDecl : String → Type → Decl
  constructor GrammarDecl : String → List[SyntaxRule] → Decl
  constructor XformDecl : String → String → String → Decl
  constructor RuleDecl : String → List[RuleCase] → Decl

  // ==========================================================================
  // Types
  // ==========================================================================
  constructor SortRef : String → Type
  constructor Arrow : Type → Type → Type
  constructor ListOf : Type → Type
  constructor Product : Type → Type → Type
  constructor TypeApp : String → List[Type] → Type
  constructor TypeVar : String → Type

  // ==========================================================================
  // Grammar Rules
  // ==========================================================================
  constructor SynRule : List[SyntaxToken] → SyntaxArg → SyntaxRule
  
  // Tokens
  constructor Literal : String → SyntaxToken
  constructor NonTerm : String → String → SyntaxToken   // name, modifier (*, +, ?)
  
  // Arguments
  constructor ArgRef : String → SyntaxArg
  constructor ArgLit : String → SyntaxArg
  constructor ArgStrLit : String → SyntaxArg
  constructor ArgWrap : String → SyntaxArg → SyntaxArg
  constructor ArgCon : String → List[SyntaxArg] → SyntaxArg
  constructor ArgHole : SyntaxArg

  // ==========================================================================
  // Transform Rules
  // ==========================================================================
  constructor Rule : String → List[RuleCase] → Rule
  constructor Case : Pattern → Pattern → RuleCase
  constructor CaseGuarded : Pattern → RuleGuard → Pattern → RuleCase
  
  // Guards
  constructor IsConstructor : String → String → RuleGuard
  constructor Equals : Pattern → Pattern → RuleGuard

  // ==========================================================================
  // Meta-level Patterns
  // ==========================================================================
  constructor PVar : String → Pattern
  constructor PCon : String → List[Pattern] → Pattern
  constructor PApp : Pattern → Pattern → Pattern
  constructor PSubst : Pattern → String → Pattern → Pattern

  // ==========================================================================
  // Grammar: Parse .phi files
  // ==========================================================================
  
  grammar spec {
    "language" IDENT "{" decl* "}" => LangSpec(IDENT, decl)
  }

  grammar decl {
    "sort" IDENT => SortDecl(IDENT)
    "constructor" IDENT ":" type => ConstructorDecl(IDENT, type)
    "grammar" IDENT "{" syntaxRule* "}" => GrammarDecl(IDENT, syntaxRule)
    "xform" IDENT ":" IDENT "⇄" IDENT => XformDecl(IDENT, IDENT, IDENT)
    "rule" qualifiedName "{" ruleCase "}" => RuleDecl(qualifiedName, ruleCase)
  }

  grammar type {
    IDENT => SortRef(IDENT)
    type "→" type => Arrow(type, type)
    "List" "[" type "]" => ListOf(type)
    type "×" type => Product(type, type)
  }

  grammar syntaxRule {
    syntaxToken+ "=>" syntaxArg => SynRule(syntaxToken, syntaxArg)
  }

  grammar syntaxToken {
    STRING => Literal(STRING)
    IDENT => NonTerm(IDENT, "")
    IDENT "*" => NonTerm(IDENT, "*")
    IDENT "+" => NonTerm(IDENT, "+")
    IDENT "?" => NonTerm(IDENT, "?")
  }

  grammar syntaxArg {
    IDENT => ArgRef(IDENT)
    STRING => ArgStrLit(STRING)
    IDENT "(" syntaxArg* ")" => ArgCon(IDENT, syntaxArg)
    "?" => ArgHole
  }

  grammar pattern {
    IDENT => PVar(IDENT)
    IDENT "(" pattern* ")" => PCon(IDENT, pattern)
    pattern pattern => PApp(pattern, pattern)
  }

  grammar ruleCase {
    pattern "↦" pattern => Case(pattern, pattern)
    pattern "|" guard "↦" pattern => CaseGuarded(pattern, guard, pattern)
  }
  
  grammar guard {
    IDENT "is" IDENT => IsConstructor(IDENT, IDENT)
    pattern "==" pattern => Equals(pattern, pattern)
  }
}
