// ===========================================================
// Calculus of Constructions (CoC) — The Apex of the Lambda Cube
// ===========================================================
// The most sophisticated type system in classical type theory.
// Combines all four axes of the Lambda Cube:
//   λ→ : Terms depending on terms (functions)
//   λP : Terms depending on types (polymorphism) 
//   λω : Types depending on types (type operators)
//   λΠ : Types depending on terms (dependent types)
//
// This is the foundation of proof assistants like Coq and Lean.
// Curry-Howard: Proofs are programs, propositions are types.
// ===========================================================

language CoC {

  // =========================================================
  // Abstract Syntax (Sorts and Constructors)
  // =========================================================
  
  sort Term
  
  // Universes
  constructor Star  : Term              // * (Type)
  constructor Box   : Term              // □ (Kind)
  
  // Core terms
  constructor Var   : String → Term
  constructor Pi    : String → Term → Term → Term     // Πx:A. B
  constructor Lam   : String → Term → Term → Term     // λx:A. t
  constructor App   : Term → Term → Term              // f t

  // =========================================================
  // Concrete Syntax (Grammar)
  // =========================================================
  // Parses actual CoC notation into the abstract syntax above.
  //
  // Examples:
  //   *                           → Star
  //   □                           → Box
  //   x                           → Var("x")
  //   λx:A. t                     → Lam("x", A, t)
  //   Πx:A. B                     → Pi("x", A, B)
  //   ∀x:A. B                     → Pi("x", A, B)
  //   A → B                       → Pi("_", A, B)
  //   f t                         → App(f, t)
  //   (t)                         → t
  
  grammar term {
    // Universes
    "*"                             => Star
    "Type"                          => Star
    "□"                             => Box
    "Kind"                          => Box
    
    // Variables
    IDENT                           => Var(IDENT)
    
    // Pi types (dependent function)
    "Π" IDENT ":" term "." term     => Pi(IDENT, term, term)
    "∀" IDENT ":" term "." term     => Pi(IDENT, term, term)
    "forall" IDENT ":" term "." term => Pi(IDENT, term, term)
    
    // Non-dependent function (sugar for Pi with unused var)
    term "→" term                   => Pi("_", term, term)
    term "->" term                  => Pi("_", term, term)
    
    // Lambda abstraction
    "λ" IDENT ":" term "." term     => Lam(IDENT, term, term)
    "\\" IDENT ":" term "." term    => Lam(IDENT, term, term)
    "fun" IDENT ":" term "." term   => Lam(IDENT, term, term)
    
    // Application (left associative)
    term term                       => App(term, term)
    
    // Parentheses
    "(" term ")"                    => term
  }

  // =========================================================
  // Contexts
  // =========================================================
  
  sort Context
  constructor Empty  : Context
  constructor Extend : Context → String → Term → Context
  
  grammar context {
    "·"                             => Empty
    "∅"                             => Empty
    context "," IDENT ":" term      => Extend(context, IDENT, term)
  }

  // =========================================================
  // Judgments (for display/documentation)
  // =========================================================
  
  sort Judgment
  constructor JType  : Context → Term → Term → Judgment    // Γ ⊢ t : T
  constructor JKind  : Context → Term → Judgment           // Γ ⊢ T : *
  constructor JCtx   : Context → Judgment                  // ⊢ Γ ctx
  constructor JEq    : Context → Term → Term → Judgment    // Γ ⊢ t ≡ u

  grammar judgment {
    context "⊢" term ":" term       => JType(context, term, term)
    context "⊢" term "type"         => JKind(context, term)
    "⊢" context "ctx"               => JCtx(context)
    context "⊢" term "≡" term       => JEq(context, term, term)
  }

  // =========================================================
  // Substitution
  // =========================================================
  
  xform Subst : String → Term → Term ⇄ Term
  rule Subst {
    _, _, Star                      ↦ Star
    _, _, Box                       ↦ Box
    x, s, Var(y) | x = y            ↦ s
    x, _, Var(y) | x ≠ y            ↦ Var(y)
    x, s, Pi(y, a, b) | x = y       ↦ Pi(y, Subst(x, s, a), b)
    x, s, Pi(y, a, b) | x ≠ y       ↦ Pi(y, Subst(x, s, a), Subst(x, s, b))
    x, s, Lam(y, a, t) | x = y      ↦ Lam(y, Subst(x, s, a), t)
    x, s, Lam(y, a, t) | x ≠ y      ↦ Lam(y, Subst(x, s, a), Subst(x, s, t))
    x, s, App(f, u)                 ↦ App(Subst(x, s, f), Subst(x, s, u))
  }

  // =========================================================
  // Reduction
  // =========================================================
  
  xform BetaStep : Term ⇄ Term
  rule BetaStep {
    App(Lam(x, _, t), u)  ↦ Subst(x, u, t)
  }
  
  xform Reduce : Term ⇄ Term
  rule Reduce {
    Star                        ↦ Star
    Box                         ↦ Box
    Var(x)                      ↦ Var(x)
    Pi(x, a, b)                 ↦ Pi(x, Reduce(a), Reduce(b))
    Lam(x, a, t)                ↦ Lam(x, Reduce(a), Reduce(t))
    App(Lam(x, _, t), u)        ↦ Reduce(Subst(x, u, t))
    App(f, u)                   ↦ App(Reduce(f), Reduce(u))
  }
  
  strategy Normalize := fixpoint Reduce

  // =========================================================
  // Equality
  // =========================================================
  
  xform AlphaEq : Term → Term ⇄ Bool
  rule AlphaEq {
    Star, Star                              ↦ True
    Box, Box                                ↦ True
    Var(x), Var(y)                          ↦ x = y
    Pi(x, a1, b1), Pi(y, a2, b2)            ↦ 
      and(AlphaEq(a1, a2), AlphaEq(b1, Subst(y, Var(x), b2)))
    Lam(x, a1, t1), Lam(y, a2, t2)          ↦
      and(AlphaEq(a1, a2), AlphaEq(t1, Subst(y, Var(x), t2)))
    App(f1, u1), App(f2, u2)                ↦ and(AlphaEq(f1, f2), AlphaEq(u1, u2))
    _, _                                    ↦ False
  }
  
  xform BetaEq : Term → Term ⇄ Bool
  rule BetaEq {
    t1, t2 ↦ AlphaEq(Normalize(t1), Normalize(t2))
  }

  // =========================================================
  // Type Checking
  // =========================================================
  
  xform Lookup : Context → String ⇄ Option[Term]
  rule Lookup {
    Empty, _                    ↦ None
    Extend(_, x, t), y | x = y  ↦ Some(t)
    Extend(ctx, _, _), y        ↦ Lookup(ctx, y)
  }
  
  xform IsSort : Term ⇄ Bool
  rule IsSort {
    Star  ↦ True
    Box   ↦ True
    _     ↦ False
  }
  
  // Inference: Γ ⊢ t : T
  xform Infer : Context → Term ⇄ Option[Term]
  rule Infer {
    _, Star                       ↦ Some(Box)
    _, Box                        ↦ Some(Box)
    ctx, Var(x)                   ↦ Lookup(ctx, x)
    
    ctx, Pi(x, a, b)              ↦
      case Infer(ctx, a) of
        Some(s1) | IsSort(s1) →
          case Infer(Extend(ctx, x, a), b) of
            Some(s2) | IsSort(s2) → Some(s2)
            _ → None
        _ → None
    
    ctx, Lam(x, a, t)             ↦
      case Infer(ctx, a) of
        Some(s) | IsSort(s) →
          case Infer(Extend(ctx, x, a), t) of
            Some(b) → Some(Pi(x, a, b))
            None    → None
        _ → None
    
    ctx, App(f, u)                ↦
      case Infer(ctx, f) of
        Some(Pi(x, a, b)) →
          case Check(ctx, u, a) of
            True  → Some(Subst(x, u, b))
            False → None
        _ → None
  }
  
  xform Check : Context → Term → Term ⇄ Bool
  rule Check {
    ctx, t, expected ↦
      case Infer(ctx, t) of
        Some(actual) → BetaEq(actual, expected)
        None         → False
  }

  // =========================================================
  // Pretty Printing (Reverse of Grammar)
  // =========================================================
  
  xform Pretty : Term ⇄ String
  rule Pretty {
    Star                ↦ "*"
    Box                 ↦ "□"
    Var(x)              ↦ x
    Pi("_", a, b)       ↦ concat(Pretty(a), " → ", Pretty(b))
    Pi(x, a, b)         ↦ concat("Π", x, ":", Pretty(a), ". ", Pretty(b))
    Lam(x, a, t)        ↦ concat("λ", x, ":", Pretty(a), ". ", Pretty(t))
    App(f, u)           ↦ concat("(", Pretty(f), " ", Pretty(u), ")")
  }

  // =========================================================
  // Standard Library
  // =========================================================
  
  // Identity: λA:*. λx:A. x
  // Parsed from: λA:*. λx:A. x
  def id = parse term "λA:*. λx:A. x"
  
  // Composition: λA:*. λB:*. λC:*. λf:B→C. λg:A→B. λx:A. f (g x)
  def compose = parse term "λA:*. λB:*. λC:*. λf:(B → C). λg:(A → B). λx:A. f (g x)"
  
  // False (empty type): ∀P:*. P
  def False = parse term "∀P:*. P"
  
  // True (unit type): ∀P:*. P → P  
  def True = parse term "∀P:*. P → P"
  
  // Negation: A → False
  def Not = parse term "λA:*. A → (∀P:*. P)"
  
  // Conjunction: ∀P:*. (A → B → P) → P
  def And = parse term "λA:*. λB:*. ∀P:*. (A → B → P) → P"
  
  // Disjunction: ∀P:*. (A → P) → (B → P) → P
  def Or = parse term "λA:*. λB:*. ∀P:*. (A → P) → (B → P) → P"

  // =========================================================
  // Church Numerals
  // =========================================================
  
  // Nat = ∀X:*. X → (X → X) → X
  def Nat = parse term "∀X:*. X → (X → X) → X"
  
  // zero = λX:*. λz:X. λs:X→X. z
  def zero = parse term "λX:*. λz:X. λs:(X → X). z"
  
  // succ = λn:Nat. λX:*. λz:X. λs:X→X. s (n X z s)
  def succ = parse term "λn:(∀X:*. X → (X → X) → X). λX:*. λz:X. λs:(X → X). s (n X z s)"
  
  // add = λm:Nat. λn:Nat. λX:*. λz:X. λs:X→X. m X (n X z s) s
  def add = parse term "λm:(∀X:*. X → (X → X) → X). λn:(∀X:*. X → (X → X) → X). λX:*. λz:X. λs:(X → X). m X (n X z s) s"

  // =========================================================
  // Leibniz Equality
  // =========================================================
  
  // Eq A x y = ∀P:(A→*). P x → P y
  def Eq = parse term "λA:*. λx:A. λy:A. ∀P:(A → *). (P x) → (P y)"
  
  // refl : ∀A:*. ∀x:A. Eq A x x
  // refl = λA. λx. λP. λpx. px
  def refl = parse term "λA:*. λx:A. λP:(A → *). λpx:(P x). px"
  
  // sym : ∀A:*. ∀x:A. ∀y:A. Eq A x y → Eq A y x
  // Given eq : ∀P. P x → P y, return ∀P. P y → P x
  // Instantiate eq with (λz. P z → P x), apply id, then py
  def sym = parse term "λA:*. λx:A. λy:A. λeq:(∀P:(A → *). (P x) → (P y)). λP:(A → *). λpy:(P y). eq (λz:A. (P z) → (P x)) (λpx:(P x). px) py"
  
  // trans : ∀A:*. ∀x y z:A. Eq x y → Eq y z → Eq x z
  def trans = parse term "λA:*. λx:A. λy:A. λz:A. λeq1:(∀P:(A → *). (P x) → (P y)). λeq2:(∀P:(A → *). (P y) → (P z)). λP:(A → *). λpx:(P x). eq2 P (eq1 P px)"

  // =========================================================
  // Example Terms (using grammar)
  // =========================================================
  
  def example_id_type = parse term "∀A:*. A → A"
  def example_nat_type = parse term "∀X:*. X → (X → X) → X"
  def example_polymorphic_const = parse term "λA:*. λB:*. λx:A. λy:B. x"

  // =========================================================
  // Test Definitions
  // =========================================================
  
  def test_parse_star = parse term "*"
  def test_parse_box = parse term "□"
  def test_parse_var = parse term "x"
  def test_parse_arrow = parse term "A → B"
  def test_parse_pi = parse term "∀x:A. B"
  def test_parse_lam = parse term "λx:A. x"
  def test_parse_app = parse term "f x"
  def test_parse_nested = parse term "(λx:*. x) *"
  
  def test_id_type = Infer(Empty, id)
  def test_zero_type = Infer(Empty, zero)
  def test_normalize_id_star = Normalize(App(App(id, Star), Nat))

  // =========================================================
  // Strategies
  // =========================================================
  
  strategy typecheck := Infer(Empty, _)
  strategy normalize := Normalize
  strategy pretty := Pretty
}
