// =============================================================================
// Meta: The Language of Interpreters
// =============================================================================
// Defines the semantic primitives for pattern matching, substitution,
// and evaluation. This is the "runtime" that phi2scala.phi targets.
//
// Code Generation Structure:
//   phi/meta/           <- Data types (stable, hand-written or rarely regenerated)
//     Val.scala         <- Val, Env, Pat, Result enums
//     Syntax.scala      <- Expr enum
//     Core.scala        <- Dispatcher (just delegates to gen/)
//   phi/meta/gen/       <- Operations (generated from rules below)
//     Eval.scala        <- Expr.eval extensions (from xform Eval)
//     Match.scala       <- Pat.matchWith extensions (from xform Match)
//     Show.scala        <- *.show extensions (from xform Show)
//
// Each xform generates a file in gen/. Each rule generates an extension method.

language Meta {
  // ==========================================================================
  // Core Semantic Sorts (→ enums in Val.scala, Syntax.scala)
  // ==========================================================================
  sort Val           // Runtime values
  sort Env           // Variable bindings  
  sort Pat           // Patterns for matching
  sort Expr          // Expressions to evaluate
  sort Result        // Match/eval results
  
  // ==========================================================================
  // Values - The Universal AST
  // ==========================================================================
  constructor VCon : String → List[Val] → Val        // Constructor application
  constructor VStr : String → Val                     // String literal
  constructor VInt : Int → Val                        // Integer literal
  constructor VList : List[Val] → Val                 // List value
  
  // ==========================================================================
  // Environments
  // ==========================================================================
  constructor EmptyEnv : Env
  constructor Bind : String → Val → Env → Env
  
  // ==========================================================================
  // Patterns
  // ==========================================================================
  constructor PVar : String → Pat                     // Variable pattern
  constructor PCon : String → List[Pat] → Pat         // Constructor pattern
  constructor PWild : Pat                             // Wildcard
  constructor PLit : Val → Pat                        // Literal pattern
  
  // ==========================================================================
  // Expressions
  // ==========================================================================
  constructor EVar : String → Expr                    // Variable reference
  constructor ECon : String → List[Expr] → Expr       // Constructor call
  constructor EApp : Expr → Expr → Expr               // Application
  constructor ELam : String → Expr → Expr             // Lambda
  constructor ELet : String → Expr → Expr → Expr      // Let binding
  constructor EMatch : Expr → List[Expr] → Expr       // Pattern match
  constructor ECase : Pat → Expr → Expr               // Case clause
  
  // ==========================================================================
  // Results
  // ==========================================================================
  constructor ROk : Val → Env → Result                // Successful match
  constructor RFail : Result                          // Match failure
  
  // ==========================================================================
  // Grammars for Reading/Writing Values
  // ==========================================================================
  grammar val {
    IDENT "(" val* ")" => VCon(IDENT, val)
    IDENT => VCon(IDENT, List)
    STRING => VStr(STRING)
    INT => VInt(INT)
    "[" val* "]" => VList(val)
  }
  
  grammar pat {
    IDENT "(" pat* ")" => PCon(IDENT, pat)
    IDENT => PVar(IDENT)
    "_" => PWild
    STRING => PLit(VStr(STRING))
  }
  
  grammar expr {
    IDENT => EVar(IDENT)
    IDENT "(" expr* ")" => ECon(IDENT, expr)
    expr expr => EApp(expr, expr)
    "λ" IDENT "." expr => ELam(IDENT, expr)
    "let" IDENT "=" expr "in" expr => ELet(IDENT, expr, expr)
    "match" expr "{" case* "}" => EMatch(expr, case)
  }
  
  grammar case {
    pat "=>" expr => ECase(pat, expr)
  }
  
  // ==========================================================================
  // Core Operations (each xform → gen/*.scala)
  // ==========================================================================
  
  // Pattern matching: (Pat, Val, Env) → Result
  // → gen/Match.scala: extension (pat: Pat) def matchWith(value: Val, env: Env): Result
  xform Match : Pat ⇄ Result
  
  // Evaluation: (Expr, Env) → Val  
  // → gen/Eval.scala: extension (expr: Expr) def eval(env: Env): Val
  xform Eval : Expr ⇄ Val
  
  // Pretty printing: Val|Pat|Expr → String
  // → gen/Show.scala: extension (v: Val) def show: String, etc.
  // NOTE: When a grammar exists for a sort, Show is derived from the grammar
  //       (bidirectional: parse ↔ render). Only sorts without grammars need
  //       explicit Show rules.
  xform Show : Val ⇄ String
  
  // Substitution: (Expr, Env) → Expr
  // → gen/Subst.scala (future)
  xform Subst : Expr ⇄ Expr
  
  // ==========================================================================
  // Match Rules
  // ==========================================================================
  
  // Variable matches anything, binds it
  rule Match.var {
    PVar(name) ↦ ROk(val, Bind(name, val, env))
  }
  
  // Constructor matches if names equal and args match
  rule Match.con {
    PCon(name, pats) ↦ 
      Match.args(pats, args, env)
  }
  
  // Wildcard matches anything, binds nothing
  rule Match.wild {
    PWild ↦ ROk(val, env)
  }
  
  // Literal matches if equal
  rule Match.lit {
    PLit(expected) ↦ ROk(val, env)
  }
  
  // ==========================================================================
  // Eval Rules
  // ==========================================================================
  
  // Variable lookup
  rule Eval.var {
    EVar(name) ↦ Lookup(name, env)
  }
  
  // Constructor: evaluate args, build value
  rule Eval.con {
    ECon(name, args) ↦ VCon(name, Eval.list(args, env))
  }
  
  // Application: evaluate both, apply
  rule Eval.app {
    EApp(f, x) ↦ Apply(Eval.forward(f), Eval.forward(x))
  }
  
  // Lambda: create closure
  rule Eval.lam {
    ELam(param, body) ↦ VClosure(param, body, env)
  }
  
  // Match: evaluate scrutinee, try cases
  rule Eval.match {
    EMatch(scrut, cases) ↦ TryCases(Eval.forward(scrut), cases, env)
  }
  
  // Let binding: evaluate value, extend env, evaluate body
  rule Eval.let {
    ELet(name, value, body) ↦ Eval.forward(body, Bind(name, Eval.forward(value), env))
  }
  
  // Case clause (shouldn't be evaluated directly)
  rule Eval.case {
    ECase(pat, body) ↦ Error("ECase evaluated directly")
  }
  
  // ==========================================================================
  // Show Rules (→ gen/Show.scala)
  // ==========================================================================
  // NOTE: Val, Pat, Expr have grammars above, so their Show is derived from
  // the grammar (bidirectional rendering). These explicit rules are only
  // needed for sorts WITHOUT grammars, or to override grammar-derived rendering.
  
  // Env.show (no grammar for Env)
  rule Show.emptyenv {
    EmptyEnv ↦ "{}"
  }
  
  rule Show.bind {
    Bind(name, value, rest) ↦ Concat("{", name, " -> ", Show.forward(value), ", ", Show.forward(rest), "}")
  }
  
  // Result.show (no grammar for Result)
  rule Show.ok {
    ROk(val, env) ↦ Concat("ROk(", Show.forward(val), ", ", Show.forward(env), ")")
  }
  
  rule Show.fail {
    RFail ↦ "RFail"
  }
}
