// =============================================================================
// Meta: The Language of Interpreters
// =============================================================================
// Defines the semantic primitives for pattern matching, substitution,
// and evaluation. This is the "runtime" that phi2scala.phi targets.
//
// Code Generation Structure:
//   phi/meta/           <- Data types (stable, hand-written or rarely regenerated)
//     Val.scala         <- Val, Env, Pat, Result enums
//     Syntax.scala      <- Expr enum
//     Core.scala        <- Dispatcher (just delegates to gen/)
//   phi/meta/gen/       <- Operations (generated from rules below)
//     Eval.scala        <- Expr.eval extensions (from xform Eval)
//     Match.scala       <- Pat.matchWith extensions (from xform Match)
//     Show.scala        <- *.show extensions (from xform Show)
//
// Each xform generates a file in gen/. Each rule generates an extension method.

language Meta {
  // ==========================================================================
  // Core Semantic Sorts (→ enums in Val.scala, Syntax.scala)
  // ==========================================================================
  sort Val           // Runtime values
  sort Env           // Variable bindings  
  sort Pat           // Patterns for matching
  sort Expr          // Expressions to evaluate
  sort Result        // Match/eval results
  
  // ==========================================================================
  // Values - The Universal AST
  // ==========================================================================
  constructor VCon : String → List[Val] → Val        // Constructor application
  constructor VStr : String → Val                     // String literal
  constructor VInt : Int → Val                        // Integer literal
  constructor VList : List[Val] → Val                 // List value
  
  // ==========================================================================
  // Environments
  // ==========================================================================
  constructor EmptyEnv : Env
  constructor Bind : String → Val → Env → Env
  
  // ==========================================================================
  // Patterns
  // ==========================================================================
  constructor PVar : String → Pat                     // Variable pattern
  constructor PCon : String → List[Pat] → Pat         // Constructor pattern
  constructor PWild : Pat                             // Wildcard
  constructor PLit : Val → Pat                        // Literal pattern
  
  // ==========================================================================
  // Expressions
  // ==========================================================================
  constructor EVar : String → Expr                    // Variable reference
  constructor ECon : String → List[Expr] → Expr       // Constructor call
  constructor EApp : Expr → Expr → Expr               // Application
  constructor ELam : String → Expr → Expr             // Lambda
  constructor ELet : String → Expr → Expr → Expr      // Let binding
  constructor EMatch : Expr → List[Expr] → Expr       // Pattern match
  constructor ECase : Pat → Expr → Expr               // Case clause
  
  // ==========================================================================
  // Results
  // ==========================================================================
  constructor ROk : Val → Env → Result                // Successful match
  constructor RFail : Result                          // Match failure
  
  // ==========================================================================
  // Grammars for Reading/Writing Values
  // ==========================================================================
  grammar val {
    IDENT "(" val* ")" => VCon(IDENT, val)
    IDENT => VCon(IDENT, List)
    STRING => VStr(STRING)
    INT => VInt(INT)
    "[" val* "]" => VList(val)
  }
  
  grammar pat {
    IDENT "(" pat* ")" => PCon(IDENT, pat)
    IDENT => PVar(IDENT)
    "_" => PWild
    STRING => PLit(VStr(STRING))
  }
  
  grammar expr {
    IDENT => EVar(IDENT)
    IDENT "(" expr* ")" => ECon(IDENT, expr)
    expr expr => EApp(expr, expr)
    "λ" IDENT "." expr => ELam(IDENT, expr)
    "let" IDENT "=" expr "in" expr => ELet(IDENT, expr, expr)
    "match" expr "{" case* "}" => EMatch(expr, case)
  }
  
  grammar case {
    pat "=>" expr => ECase(pat, expr)
  }
  
  // ==========================================================================
  // Core Operations (each xform → gen/*.scala)
  // ==========================================================================
  
  // Pattern matching: (Pat, Val, Env) → Result
  // → gen/Match.scala: extension (pat: Pat) def matchWith(value: Val, env: Env): Result
  xform Match(value: Val, env: Env) : Pat ⇄ Result
  
  // Evaluation: (Expr, Env) → Val  
  // → gen/Eval.scala: extension (expr: Expr) def eval(env: Env): Val
  xform Eval(env: Env) : Expr ⇄ Val
  
  // Pretty printing: Val|Pat|Expr → String
  // → gen/Show.scala: extension (v: Val) def show: String, etc.
  // NOTE: When a grammar exists for a sort, Show is derived from the grammar
  //       (bidirectional: parse ↔ render). Only sorts without grammars need
  //       explicit Show rules.
  xform Show : Val ⇄ String
  
  // Substitution: (Expr, Env) → Expr
  // → gen/Subst.scala (future)
  xform Subst(env: Env) : Expr ⇄ Expr
  
  // ==========================================================================
  // Match Rules
  // ==========================================================================
  
  // Variable matches anything, binds it
  rule Match.var {
    PVar(name) ↦ ROk(val, Bind(name, val, env))
  }
  
  // Constructor matches if names equal and args match
  rule Match.con {
    PCon(name, pats) ↦ 
      Match.args(pats, args, env)
  }
  
  // Wildcard matches anything, binds nothing
  rule Match.wild {
    PWild ↦ ROk(val, env)
  }
  
  // Literal matches if equal
  rule Match.lit {
    PLit(expected) ↦ ROk(val, env)
  }
  
  // ==========================================================================
  // Eval Rules
  // ==========================================================================
  
  // Variable lookup
  rule Eval.var {
    EVar(name) ↦ Lookup(name, env)
  }
  
  // Constructor: evaluate args, build value
  rule Eval.con {
    ECon(name, args) ↦ VCon(name, Eval.list(args, env))
  }
  
  // Application: evaluate both, apply
  rule Eval.app {
    EApp(f, x) ↦ Apply(Eval.forward(f), Eval.forward(x))
  }
  
  // Lambda: create closure
  rule Eval.lam {
    ELam(param, body) ↦ VClosure(param, body, env)
  }
  
  // Match: evaluate scrutinee, try cases
  rule Eval.match {
    EMatch(scrut, cases) ↦ TryCases(Eval.forward(scrut), cases, env)
  }
  
  // Let binding: evaluate value, extend env, evaluate body
  rule Eval.let {
    ELet(name, value, body) ↦ Eval.forward(body, Bind(name, Eval.forward(value), env))
  }
  
  // Case clause (shouldn't be evaluated directly)
  rule Eval.case {
    ECase(pat, body) ↦ Error("ECase evaluated directly")
  }
  
  // ==========================================================================
  // Show Rules (→ gen/Show.scala)
  // ==========================================================================
  // NOTE: Val, Pat, Expr have grammars above, so their Show is derived from
  // the grammar (bidirectional rendering). These explicit rules are only
  // needed for sorts WITHOUT grammars, or to override grammar-derived rendering.
  
  // Env.show (no grammar for Env)
  rule Show.emptyenv {
    EmptyEnv ↦ "{}"
  }
  
  rule Show.bind {
    Bind(name, value, rest) ↦ Concat("{", name, " -> ", Show.forward(value), ", ", Show.forward(rest), "}")
  }
  
  // Result.show (no grammar for Result)
  rule Show.ok {
    ROk(val, env) ↦ Concat("ROk(", Show.forward(val), ", ", Show.forward(env), ")")
  }
  
  rule Show.fail {
    RFail ↦ "RFail"
  }
  
  // ==========================================================================
  // Code Generation: Xform → ScalaFile (per-file xforms)
  // ==========================================================================
  // Each semantic xform (Eval, Match, Show, Subst) has a corresponding
  // generator xform that builds the Scala AST. GenMeta orchestrates:
  //   1. Apply GenEval to Eval xform → ScalaFile AST
  //   2. Render via scala.phi grammar → String
  //   3. Write to file
  
  // GenEval: Eval xform → gen/Eval.scala
  xform GenEval : Xform ⇄ ScalaFile
  
  rule GenEval.file {
    Xform("Eval", params, srcType, tgtType, rules) ↦ 
      ScalaPackage("phi.meta.gen", List(
        ScalaImport("phi.meta.{Val, Env, Pat, Expr, Result}"),
        ScalaImport("Expr.*"),
        ScalaObject("Eval", GenEval.members(rules))
      ))
  }
  
  rule GenEval.members {
    rules ↦ Cons(
      GenEval.dispatch(rules),
      GenEval.extensions(rules)
    )
  }
  
  rule GenEval.dispatch {
    rules ↦ ExtensionOn("e", "Expr", List(
      DispatchDef("eval", Param("env", "Env"), TypeName("Val"), "e", GenEval.cases(rules))
    ))
  }
  
  rule GenEval.cases {
    Cons(Rule(name, cases), rest) ↦ Cons(
      GenEval.oneCase(name, cases),
      GenEval.cases(rest)
    )
  }
  
  rule GenEval.cases {
    Nil ↦ Nil
  }
  
  // oneCase receives Args(name, cases) where cases = Cons(RuleCase(pat, body), Nil)
  // pat is the pattern like PCon("EVar", Cons(PVar("name"), Nil))
  // We extract the constructor name from the pattern
  rule GenEval.oneCase {
    Args(name, Cons(RuleCase(PCon(conName, patArgs), body), rest)) ↦ 
      TypeCase("e", conName, Call(GenEval.methodName(name), List(Ident("env"))))
  }
  
  // methodName: "Eval.var" → "evalVar"  
  rule GenEval.methodName {
    name ↦ name  // TODO: proper name transformation
  }
  
  rule GenEval.extensions {
    Cons(Rule(name, cases), rest) ↦ Cons(
      GenEval.extension(name, cases),
      GenEval.extensions(rest)
    )
  }
  
  rule GenEval.extensions {
    Nil ↦ Nil
  }
  
  // extension receives Args(name, cases)
  rule GenEval.extension {
    Args(name, Cons(RuleCase(PCon(conName, patArgs), body), rest)) ↦ 
      ExtensionOn("e", conName, List(
        DefMethod(GenEval.methodName(name), Param("env", "Env"), TypeName("Val"),
                  Placeholder)
      ))
  }
  
  // GenMatch: Match xform → gen/Match.scala
  xform GenMatch : Xform ⇄ ScalaFile
  
  rule GenMatch.file {
    Xform("Match", params, srcType, tgtType, rules) ↦ 
      ScalaPackage("phi.meta.gen", List(
        ScalaImport("phi.meta.{Val, Env, Pat, Expr, Result}"),
        ScalaImport("Pat.*"),
        ScalaObject("Match", GenMatch.members(rules))
      ))
  }
  
  rule GenMatch.members {
    rules ↦ Cons(
      GenMatch.dispatch(rules),
      GenMatch.extensions(rules)
    )
  }
  
  rule GenMatch.dispatch {
    rules ↦ ExtensionOn("p", "Pat", List(
      DispatchDef("matchWith", Param("value", "Val"), TypeName("Result"), "p", GenMatch.cases(rules))
    ))
  }
  
  rule GenMatch.cases {
    Cons(Rule(name, cases), rest) ↦ Cons(
      GenMatch.oneCase(name, cases),
      GenMatch.cases(rest)
    )
  }
  
  rule GenMatch.cases {
    Nil ↦ Nil
  }
  
  // oneCase extracts constructor name from the pattern
  rule GenMatch.oneCase {
    Args(name, Cons(RuleCase(PCon(conName, patArgs), body), rest)) ↦ 
      TypeCase("p", conName, Call(GenMatch.methodName(name), List(Ident("value"))))
  }
  
  rule GenMatch.methodName {
    name ↦ name
  }
  
  rule GenMatch.extensions {
    Cons(Rule(name, cases), rest) ↦ Cons(
      GenMatch.extension(name, cases),
      GenMatch.extensions(rest)
    )
  }
  
  rule GenMatch.extensions {
    Nil ↦ Nil
  }
  
  // extension for specific pattern type
  rule GenMatch.extension {
    Args(name, Cons(RuleCase(PCon(conName, patArgs), body), rest)) ↦ 
      ExtensionOn("p", conName, List(
        DefMethod(GenMatch.methodName(name), Param("value", "Val"), TypeName("Result"),
                  Placeholder)
      ))
  }
  
  // GenShow: Show xform → gen/Show.scala  
  xform GenShow : Xform ⇄ ScalaFile
  
  rule GenShow.file {
    Xform("Show", params, srcType, tgtType, rules) ↦ 
      ScalaPackage("phi.meta.gen", List(
        ScalaImport("phi.meta.{Val, Env, Pat, Expr, Result}"),
        ScalaObject("Show", GenShow.members(rules))
      ))
  }
  
  rule GenShow.members {
    rules ↦ Cons(
      GenShow.dispatch(rules),
      GenShow.extensions(rules)
    )
  }
  
  rule GenShow.cases {
    Cons(Rule(name, cases), rest) ↦ Cons(
      GenShow.oneCase(name, cases),
      GenShow.cases(rest)
    )
  }
  
  rule GenShow.cases {
    Nil ↦ Nil
  }
  
  rule GenShow.extensions {
    Cons(Rule(name, cases), rest) ↦ Cons(
      GenShow.extension(name, cases),
      GenShow.extensions(rest)
    )
  }
  
  rule GenShow.extensions {
    Nil ↦ Nil
  }
  
  // GenSubst: Subst xform → gen/Subst.scala
  xform GenSubst : Xform ⇄ ScalaFile
  
  rule GenSubst.file {
    Xform("Subst", params, srcType, tgtType, rules) ↦ 
      ScalaPackage("phi.meta.gen", List(
        ScalaImport("phi.meta.{Val, Env, Pat, Expr, Result}"),
        ScalaImport("Expr.*"),
        ScalaObject("Subst", GenSubst.members(rules))
      ))
  }
  
  rule GenSubst.members {
    rules ↦ Cons(
      GenSubst.dispatch(rules),
      GenSubst.extensions(rules)
    )
  }
  
  rule GenSubst.cases {
    Cons(Rule(name, cases), rest) ↦ Cons(
      GenSubst.oneCase(name, cases),
      GenSubst.cases(rest)
    )
  }
  
  rule GenSubst.cases {
    Nil ↦ Nil
  }
  
  rule GenSubst.extensions {
    Cons(Rule(name, cases), rest) ↦ Cons(
      GenSubst.extension(name, cases),
      GenSubst.extensions(rest)
    )
  }
  
  rule GenSubst.extensions {
    Nil ↦ Nil
  }
}
