// =============================================================================
// Scala: Target language spec for code generation
// =============================================================================
// Constructors define the AST. Grammars enable bidirectional rendering.
// 
// Attribute grammar tokens:
//   \n   - newline at current indent level
//   \n+  - newline and increase indent
//   \n-  - newline and decrease indent

language Scala {
  // ----- Sorts -----
  sort ScalaFile
  sort ScalaDecl
  sort ScalaMember
  sort ScalaExpr
  sort ScalaCase
  sort ScalaParam
  sort ScalaType
  
  // ----- File-level constructs -----
  constructor ScalaPackage : String → List[ScalaDecl] → ScalaFile
  
  // ----- Declarations -----  
  constructor ScalaImport : String → ScalaDecl
  constructor ScalaObject : String → List[ScalaMember] → ScalaDecl
  constructor ScalaTrait : String → List[ScalaParam] → List[ScalaMember] → ScalaDecl
  constructor ScalaTrait0 : String → List[ScalaMember] → ScalaDecl  // Trait without type params (name can include [A])
  constructor CaseClassDecl : String → List[ScalaParam] → ScalaDecl
  constructor DeclDocComment : String → ScalaDecl → ScalaDecl
  constructor BlankDecl : ScalaDecl
  
  // ----- Members (inside object) -----
  constructor Comment : String → ScalaMember → ScalaMember
  constructor DocComment : String → ScalaMember → ScalaMember
  constructor BlankLine : ScalaMember
  constructor RawMember : String → ScalaMember  // Raw Scala code, rendered as-is
  constructor ExtensionOn : String → String → List[ScalaMember] → ScalaMember
  constructor DefMethod : String → ScalaParam → ScalaType → ScalaExpr → ScalaMember
  constructor DefMethod0 : String → ScalaType → ScalaExpr → ScalaMember  // Method with no params
  constructor DefMethodN : String → List[ScalaParam] → ScalaType → ScalaExpr → ScalaMember  // Multi-param method
  constructor DefMethodAbstract : String → List[ScalaParam] → ScalaType → ScalaMember  // Abstract method (no body)
  constructor DefMethodAbstract0 : String → ScalaType → ScalaMember  // Abstract method with no params
  constructor DispatchDef : String → ScalaParam → ScalaType → String → List[ScalaCase] → ScalaMember
  constructor DispatchDef0 : String → ScalaType → String → List[ScalaCase] → ScalaMember  // No-param dispatch
  constructor DispatchDefN : String → List[ScalaParam] → ScalaType → String → List[ScalaCase] → ScalaMember  // Multi-param dispatch
  
  // ----- Parameters -----
  constructor Param : String → String → ScalaParam
  
  // ----- Types -----
  constructor TypeName : String → ScalaType
  
  // ----- Expressions -----
  constructor Ident : String → ScalaExpr
  constructor FieldAccess : ScalaExpr → String → ScalaExpr
  constructor MethodCall : ScalaExpr → String → List[ScalaExpr] → ScalaExpr
  constructor MethodCall0 : ScalaExpr → String → ScalaExpr  // No-arg method call without parens (e.g., .show)
  constructor MethodCallCurried : ScalaExpr → String → ScalaExpr → ScalaExpr → ScalaExpr  // recv.method(arg1)(arg2)
  constructor Call : String → List[ScalaExpr] → ScalaExpr
  constructor StrLit : String → ScalaExpr  // String literal
  constructor DQuotLit : ScalaExpr  // Renders as "\""
  constructor Placeholder : ScalaExpr
  constructor MatchExpr : ScalaExpr → List[ScalaCase] → ScalaExpr  // expr match { cases }
  constructor IfExpr : ScalaExpr → ScalaExpr → ScalaExpr → ScalaExpr  // if cond then t else f
  constructor BinOp : ScalaExpr → String → ScalaExpr → ScalaExpr  // left op right
  constructor TupleExpr : List[ScalaExpr] → ScalaExpr  // (a, b, ...)
  constructor LetIn : String → ScalaExpr → ScalaExpr → ScalaExpr  // { val name = expr1; expr2 }
  constructor Lambda : String → ScalaExpr → ScalaExpr  // param => body
  constructor NL : ScalaExpr  // Newline literal (renders as \n in string context)
  
  // ----- Pattern matching cases -----
  constructor TypeCase : String → String → ScalaExpr → ScalaCase
  constructor PatCase : String → ScalaExpr → ScalaCase  // case pattern => expr
  constructor GuardedCase : String → ScalaExpr → ScalaExpr → ScalaCase  // case pattern if guard => expr
  constructor NestedMatch : String → ScalaExpr → List[ScalaCase] → ScalaCase  // case pattern => expr match { cases }
  
  // ----- Partial Functions -----
  constructor PartialFunc : ScalaCase → ScalaExpr  // { case pattern => expr }
  
  // ----- Grammars for rendering -----
  // Attribute grammar tokens:
//   NL     - newline at current indent level  
//   INDENT - increase indent for following tokens
//   DEDENT - decrease indent for following tokens
// Members/cases start with NL themselves
  grammar scalaFile {
    "package" pkgName NL scalaDecl* => ScalaPackage(pkgName, scalaDecl)
  }
  
  grammar scalaDecl {
    NL "import" importPath => ScalaImport(importPath)
    BLANKLINE => BlankDecl
    NL DOCSTART docText DOCEND wrappedDecl => DeclDocComment(docText, wrappedDecl)
    NL "object" objName ":" INDENT scalaMember* DEDENT => ScalaObject(objName, scalaMember)
    NL "trait" traitName "[" scalaParam* "]" ":" INDENT scalaMember* DEDENT => ScalaTrait(traitName, scalaParam, scalaMember)
    NL "trait" traitName0 ":" INDENT scalaMember0* DEDENT => ScalaTrait0(traitName0, scalaMember0)
    NL "case" "class" className "(" scalaParam* ")" => CaseClassDecl(className, scalaParam)
  }
  
  grammar scalaMember {
    NL COMMENT commentText wrappedMember => Comment(commentText, wrappedMember)
    NL DOCSTART docText DOCEND wrappedMember => DocComment(docText, wrappedMember)
    BLANKLINE => BlankLine
    NL rawCode => RawMember(rawCode)
    NL "extension" "(" pName ":" tName ")" INDENT scalaMember* DEDENT => ExtensionOn(pName, tName, scalaMember)
    NL "def" mName "(" scalaParam ")" ":" scalaType "=" scalaExpr => DefMethod(mName, scalaParam, scalaType, scalaExpr)
    NL "def" mName ":" scalaType "=" scalaExpr => DefMethod0(mName, scalaType, scalaExpr)
    NL "def" mName "(" scalaParam* ")" ":" scalaType "=" scalaExpr => DefMethodN(mName, scalaParam, scalaType, scalaExpr)
    NL "def" mName "(" scalaParam* ")" ":" scalaType => DefMethodAbstract(mName, scalaParam, scalaType)
    NL "def" mName0 ":" scalaType0 => DefMethodAbstract0(mName0, scalaType0)
    NL "def" mName ":" scalaType => DefMethodAbstract(mName, ?, scalaType)
    NL "def" mName "(" scalaParam ")" ":" scalaType "=" exprName "match" INDENT scalaCase* DEDENT => DispatchDef(mName, scalaParam, scalaType, exprName, scalaCase)
    NL "def" mName ":" scalaType "=" exprName "match" INDENT scalaCase* DEDENT => DispatchDef0(mName, scalaType, exprName, scalaCase)
    NL "def" mName "(" scalaParam* ")" ":" scalaType "=" exprName "match" INDENT scalaCase* DEDENT => DispatchDefN(mName, scalaParam, scalaType, exprName, scalaCase)
  }
  
  grammar scalaParam {
    pName ":" tName => Param(pName, tName)
  }
  
  grammar scalaType {
    tName => TypeName(tName)
  }
  
  grammar scalaExpr {
    recv "." mName "(" args* ")" => MethodCall(recv, mName, args)
    recv "." mName => MethodCall0(recv, mName)
    curryRecv "." curryName "(" arg1 ")" "(" arg2 ")" => MethodCallCurried(curryRecv, curryName, arg1, arg2)
    vName => Ident(vName)
    objExpr "." fieldName => FieldAccess(objExpr, fieldName)
    fName "(" scalaExprArgs* ")" => Call(fName, scalaExprArgs)
    matchExpr "match" INDENT scalaCase* DEDENT => MatchExpr(matchExpr, scalaCase)
    "if" condExpr "then" thenExpr "else" elseExpr => IfExpr(condExpr, thenExpr, elseExpr)
    leftExpr op rightExpr => BinOp(leftExpr, op, rightExpr)
    "(" tupleArgs* ")" => TupleExpr(tupleArgs)
    STRLIT strVal STRLIT => StrLit(strVal)
    DQUOT => DQuotLit
    "_" => Placeholder
    "{" INDENT NL "val" letName "=" letVal NL letBody DEDENT NL "}" => LetIn(letName, letVal, letBody)
    lambdaParam "=>" lambdaBody => Lambda(lambdaParam, lambdaBody)
    NLSTR => NL
    "{" partialCase "}" => PartialFunc(partialCase)
  }
  
  grammar scalaCase {
    NL "case" varName ":" typeName "=>" caseExpr => TypeCase(varName, typeName, caseExpr)
    NL "case" pattern "=>" bodyExpr => PatCase(pattern, bodyExpr)
    NL "case" guardPat "if" guardCond "=>" guardBody => GuardedCase(guardPat, guardCond, guardBody)
    NL "case" nestedPat "=>" nestedExpr "match" INDENT nestedCase* DEDENT => NestedMatch(nestedPat, nestedExpr, nestedCase)
  }
}
