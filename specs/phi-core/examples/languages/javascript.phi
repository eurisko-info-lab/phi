-- JavaScript: The Good Parts, Distilled
-- Generated by Phi Oracle on 2026-01-02
-- 
-- JavaScript's good parts—first-class functions, closures, prototypal inheritance, and dynamic typing—captured as a pure functional specification with proper type safety and algebraic structure.
--
-- Highlights:
--   • First-class functions as Cofree
--   • Closures as Environment Comonad
--   • Prototypes as Extensible Records
--   • Async/Promise as Free Monad
--

-- JavaScript: The Good Parts, Distilled
-- Capturing the essence of what makes JS powerful without the bad parts

module JavaScript where

import Prelude
import Control.Comonad.Cofree
import Control.Monad.Free
import Data.Record.Extensible

-- Dynamic values with proper typing
Dynamic : Type
Dynamic = 
  | Number : Double → Dynamic
  | String : Text → Dynamic  
  | Boolean : Bool → Dynamic
  | Function : (Dynamic → Dynamic) → Dynamic
  | Object : Record Dynamic → Dynamic
  | Array : List Dynamic → Dynamic
  | Null : Dynamic
  | Undefined : Dynamic

-- First-class functions - the crown jewel of JS
Function : Type → Type → Type
Function a b = a → b

-- Higher-order functions
map : ∀ a b. (a → b) → List a → List b
map f [] = []
map f (x :: xs) = f x :: map f xs

filter : ∀ a. (a → Bool) → List a → List a  
filter p [] = []
filter p (x :: xs) = 
  | p x = x :: filter p xs
  | otherwise = filter p xs

reduce : ∀ a b. (b → a → b) → b → List a → b
reduce f acc [] = acc
reduce f acc (x :: xs) = reduce f (f acc x) xs

-- Closures as Environment Comonad
Closure : Type → Type → Type
Closure env a = Cofree ((->) env) a

makeClosure : ∀ env a. env → (env → a) → Closure env a
makeClosure env f = f env :< \e → makeClosure e f

-- Prototypal inheritance as extensible records
Prototype : Type → Type
Prototype a = Record a

extend : ∀ a b. Prototype a → Record b → Prototype (a ∪ b)
extend proto methods = proto <+> methods

-- Object creation
create : ∀ a. Prototype a → Record a → Record a
create proto props = extend proto props

-- Method binding
bind : ∀ a b. Record a → (Record a → b) → b
bind obj method = method obj

-- Async operations as Free Monad
Async : Type → Type
Async = Free AsyncF

AsyncF : Type → Type
AsyncF a =
  | SetTimeout : Nat → a → AsyncF a
  | Fetch : URL → (Response → a) → AsyncF a
  | NextTick : a → AsyncF a

-- Promise-like interface
Promise : Type → Type  
Promise a = Async a

then : ∀ a b. Promise a → (a → Promise b) → Promise b
then = (>>=)

catch : ∀ a. Promise a → (Error → Promise a) → Promise a
catch p handler = p `catchError` handler

-- Event handling
Event : Type
Event = Record
  { type : Text
  , target : Dynamic
  , preventDefault : Unit → Unit
  , stopPropagation : Unit → Unit
  }

EventHandler : Type
EventHandler = Event → Unit

addEventListener : Text → EventHandler → Dynamic → Unit
addEventListener eventType handler element = 
  -- Implementation would bind to actual DOM
  unit

-- Flexible equality (the good part of ==)
looseEqual : Dynamic → Dynamic → Bool
looseEqual (Number a) (Number b) = a == b
looseEqual (String a) (String b) = a == b
looseEqual (Boolean a) (Boolean b) = a == b
looseEqual Null Undefined = True
looseEqual Undefined Null = True
looseEqual _ _ = False

-- Truthy/falsy semantics
truthy : Dynamic → Bool
truthy (Boolean False) = False
truthy (Number 0.0) = False
truthy (String "") = False
truthy Null = False
truthy Undefined = False
truthy (Number n) = not (isNaN n)
truthy _ = True

-- Examples demonstrating the good parts

-- Higher-order function composition
compose : ∀ a b c. (b → c) → (a → b) → (a → c)
compose f g x = f (g x)

-- Currying (partial application)
curry : ∀ a b c. (a → b → c) → a → (b → c)
curry f x y = f x y

-- Practical examples
example_map : List Nat
example_map = map (\x → x * 2) [1, 2, 3, 4]
-- Result: [2, 4, 6, 8]

example_closure : Closure Nat Nat
example_closure = 
  let counter = 0 in
  makeClosure counter (\c → c + 1)

example_prototype : Record { name : Text, greet : Text → Text }
example_prototype = 
  let person = { name = "Anonymous" }
      methods = { greet = \msg → "Hello, " <> msg }
  in create person methods

example_async : Promise Text
example_async = do
  response ← fetch "https://api.example.com/data"
  data ← parseJSON response
  return (show data)

-- Test suite
test_higher_order : Bool
test_higher_order = 
  let doubled = map (\x → x * 2) [1, 2, 3]
      filtered = filter (\x → x > 2) doubled
      sum = reduce (+) 0 filtered
  in sum == 10

test_closure : Bool  
test_closure =
  let makeCounter = \start → makeClosure start (\n → n + 1)
      counter = makeCounter 5
  in extract counter == 6

test_truthy : Bool
test_truthy = 
  truthy (Number 1.0) && 
  not (truthy (String "")) &&
  not (truthy Null)

-- The essence: JavaScript's power comes from treating functions as values,
-- flexible object composition, and asynchronous computation.
-- Phi preserves these while adding type safety and mathematical foundations.