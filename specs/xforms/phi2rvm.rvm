// Generated by: rvm compile
// Source: specs/xforms/phi2rvm.phi

fn main() {
    Push(Str("// =============================================================================\n// Phi to RVM Transformation\n// =============================================================================\n// Compiles Phi AST to RosettaVM bytecode.\n//\n// This is the core compiler from Phi's high-level constructs to the\n// stack-based RVM instructions.\n//\n// Transformation chain:\n//   Phi source → Phi AST → RVM Instructions → .rvm file\n//\n// The compiler handles:\n//"))
    Push(Str("Expressions (literals, variables, operators)\n//"))
    Push(Str("Control flow (if/then/else, match)\n//"))
    Push(Str("Functions (lambda, application, recursion)\n//"))
    Push(Str("Data (constructors, records, lists)\n//"))
    Push(Str("Pattern matching compilation\n\nlanguage Phi2RVM {\n\n  import Phi    // Source language\n  import RVM    // Target language\n\n  // ===========================================================================\n  // Compilation Context\n  // ===========================================================================\n\n  sort Ctx      // Compilation context\n\n  constructor\n    Ctx : Scope × Int × CodeBlock* × String* → Ctx\n    // scope, lambda counter, collected blocks, errors\n\n  sort Scope    // Variable scope\n\n  constructor\n    ScopeEmpty : Scope\n    ScopeBind  : String × Int × Scope → Scope   // name, slot, parent\n\n  // Lookup variable in scope, returns (depth, slot)\n  xform lookupVar : String × Scope ⇄ (Int × Int)?\n  rule lookupVar {\n    (x, ScopeEmpty)              ↦ None\n    (x, ScopeBind(x, slot, _))   ↦ Some(0, slot)\n    (x, ScopeBind(y, _, rest))   ↦ \n      match lookupVar(x, rest) with\n        Some(depth, slot) → Some(depth"))
    Sub
    Sub
    Sub
    Sub
    Sub
    Push(Str("1, slot)\n        None              → None\n      end\n      where x ≠ y\n  }\n\n  // ===========================================================================\n  // Main Compilation Transform\n  // ===========================================================================\n\n  xform compile : Phi.Expr × Ctx ⇄ (RVM.Instr* × Ctx)\n\n  // ---------------------------------------------------------------------------\n  // Literals\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    // Integer literal\n    (Phi.IntLit(n), ctx)\n      ↦ ([RVM.IPush(RVM.LInt(n))], ctx)\n\n    // String literal\n    (Phi.StrLit(s), ctx)\n      ↦ ([RVM.IPush(RVM.LStr(s))], ctx)\n\n    // Boolean literal\n    (Phi.BoolLit(b), ctx)\n      ↦ ([RVM.IPush(RVM.LBool(b))], ctx)\n\n    // Unit\n    (Phi.Unit, ctx)\n      ↦ ([RVM.IPush(RVM.LUnit)], ctx)\n\n    // Nil (empty list)\n    (Phi.Nil, ctx)\n      ↦ ([RVM.IPush(RVM.LNil)], ctx)\n  }\n\n  // ---------------------------------------------------------------------------\n  // Variables\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    // Variable reference\n    (Phi.Var(x), Ctx(scope, lc, blocks, errs))\n      ↦ match lookupVar(x, scope) with\n          Some(0, slot)     → ([RVM.IDup], ctx')     // top of stack\n          Some(1, slot)     → ([RVM.IOver], ctx')    // second from top\n          Some(depth, slot) → ([RVM.ILoad(slot)], ctx')\n          None              → ([RVM.ILoadGlobal(hashOf(x))], ctx')\n        end\n      where ctx' = Ctx(scope, lc, blocks, errs)\n  }\n\n  // ---------------------------------------------------------------------------\n  // Arithmetic Operators\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    // Binary operators\n    (Phi.BinOp(\"+\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IAdd], ctx2)\n\n    (Phi.BinOp(\"-\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.ISub], ctx2)\n\n    (Phi.BinOp(\"*\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IMul], ctx2)\n\n    (Phi.BinOp(\"/\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IDiv], ctx2)\n\n    (Phi.BinOp(\"%\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IMod], ctx2)\n\n    // Unary negation\n    (Phi.UnOp(\"-\", e), ctx)\n      ↦ let (c, ctx') = compile(e, ctx) in\n        (c ++ [RVM.INeg], ctx')\n  }\n\n  // ---------------------------------------------------------------------------\n  // Comparison Operators\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    (Phi.BinOp(\"==\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IEq], ctx2)\n\n    (Phi.BinOp(\"!=\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.INe], ctx2)\n\n    (Phi.BinOp(\"<\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.ILt], ctx2)\n\n    (Phi.BinOp(\"<=\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.ILe], ctx2)\n\n    (Phi.BinOp(\">\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IGt], ctx2)\n\n    (Phi.BinOp(\">=\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IGe], ctx2)\n  }\n\n  // ---------------------------------------------------------------------------\n  // Boolean Operators\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    (Phi.BinOp(\"&&\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IAnd], ctx2)\n\n    (Phi.BinOp(\"||\", e1, e2), ctx)\n      ↦ let (c1, ctx1) = compile(e1, ctx) in\n        let (c2, ctx2) = compile(e2, ctx1) in\n        (c1 ++ c2 ++ [RVM.IOr], ctx2)\n\n    (Phi.UnOp(\"!\", e), ctx)\n      ↦ let (c, ctx') = compile(e, ctx) in\n        (c ++ [RVM.INot], ctx')\n  }\n\n  // ---------------------------------------------------------------------------\n  // Control Flow: If-Then-Else\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    (Phi.If(cond, thenE, elseE), ctx)\n      ↦ let (cCond, ctx1) = compile(cond, ctx) in\n        let (cThen, ctx2) = compile(thenE, ctx1) in\n        let (cElse, ctx3) = compile(elseE, ctx2) in\n        let thenLen = length(cThen)"))
    Push(Str("1 in     // +1 for jump over else\n        let elseLen = length(cElse) in\n        ( cCond \n          ++ [RVM.IJumpIfNot(thenLen"))
    Push(Str("1)]     // Skip to else\n          ++ cThen\n          ++ [RVM.IJump(elseLen"))
    Push(Str("1)]          // Skip over else\n          ++ cElse\n        , ctx3)\n  }\n\n  // ---------------------------------------------------------------------------\n  // Let Bindings\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    (Phi.Let(x, val, body), Ctx(scope, lc, blocks, errs))\n      ↦ let (cVal, ctx1) = compile(val, Ctx(scope, lc, blocks, errs)) in\n        let slot = scopeSize(scope) in\n        let scope' = ScopeBind(x, slot, scope) in\n        let (cBody, Ctx(_, lc', blocks', errs')) = \n              compile(body, Ctx(scope', lc, blocks, errs)) in\n        // Value stays on stack during body, then swap and pop\n        ( cVal ++ cBody ++ [RVM.ISwap, RVM.IPop]\n        , Ctx(scope, lc', blocks', errs'))\n  }\n\n  // ---------------------------------------------------------------------------\n  // Functions: Lambda\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    (Phi.Lambda(params, body), Ctx(scope, lc, blocks, errs))\n      ↦ let name = \"lambda_\" ++ toString(lc) in\n        let lc' = lc"))
    Push(Str("1 in\n        // Build scope with parameters\n        let paramScope = foldl(\n              fn(s, (p, i)) → ScopeBind(p, i, s),\n              ScopeEmpty,\n              zip(params, range(0, length(params)))\n            ) in\n        let (cBody, Ctx(_, lc'', moreBlocks, errs')) = \n              compile(body, Ctx(paramScope, lc', blocks, errs)) in\n        let lambdaCode = cBody ++ [RVM.IReturn] in\n        let lambdaHash = hashOf(name) in\n        let lambdaBlock = RVM.CodeBlock(\n              lambdaHash, \n              Some(name), \n              length(params), \n              0,                           // locals\n              scopeSize(scope),            // captures\n              lambdaCode\n            ) in\n        ( [RVM.IClosure(lambdaHash, scopeSize(scope))]\n        , Ctx(scope, lc'', [lambdaBlock | moreBlocks], errs'))\n  }\n\n  // ---------------------------------------------------------------------------\n  // Functions: Application\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    // Single argument application\n    (Phi.App(func, [arg]), ctx)\n      ↦ let (cArg, ctx1) = compile(arg, ctx) in\n        let (cFunc, ctx2) = compile(func, ctx1) in\n        (cArg ++ cFunc ++ [RVM.IApply], ctx2)\n\n    // Multi-argument application\n    (Phi.App(func, args), ctx) where length(args)"))
    Push(Str("1\n      ↦ let (cArgs, ctx1) = compileList(args, ctx) in\n        let (cFunc, ctx2) = compile(func, ctx1) in\n        (cArgs ++ cFunc ++ [RVM.IApplyN(length(args))], ctx2)\n\n    // Named function call\n    (Phi.Call(name, args), ctx)\n      ↦ let (cArgs, ctx') = compileList(args, ctx) in\n        let hash = hashOf(name) in\n        (cArgs ++ [RVM.ICallN(hash, length(args))], ctx')\n  }\n\n  // ---------------------------------------------------------------------------\n  // Data: Lists\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    // List literal\n    (Phi.List(elems), ctx)\n      ↦ let (cElems, ctx') = compileList(elems, ctx) in\n        (cElems ++ [RVM.IMkList(length(elems))], ctx')\n\n    // Cons\n    (Phi.BinOp(\"::\", head, tail), ctx)\n      ↦ let (cHead, ctx1) = compile(head, ctx) in\n        let (cTail, ctx2) = compile(tail, ctx1) in\n        (cHead ++ cTail ++ [RVM.ICons], ctx2)\n  }\n\n  // ---------------------------------------------------------------------------\n  // Data: Tuples\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    (Phi.Tuple(elems), ctx)\n      ↦ let (cElems, ctx') = compileList(elems, ctx) in\n        (cElems ++ [RVM.IMkTuple(length(elems))], ctx')\n  }\n\n  // ---------------------------------------------------------------------------\n  // Data: Constructors\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    (Phi.Constructor(typeName, ctorName, tag, args), ctx)\n      ↦ let (cArgs, ctx') = compileList(args, ctx) in\n        let typeHash = hashOf(typeName) in\n        (cArgs ++ [RVM.IMkCon(typeHash, tag, length(args))], ctx')\n  }\n\n  // ---------------------------------------------------------------------------\n  // Pattern Matching\n  // ---------------------------------------------------------------------------\n\n  rule compile {\n    (Phi.Match(scrutinee, cases), ctx)\n      ↦ let (cScrut, ctx1) = compile(scrutinee, ctx) in\n        let (cMatch, ctx2) = compileCases(cases, ctx1) in\n        (cScrut ++ cMatch, ctx2)\n  }\n\n  // Compile match cases to jump table\n  xform compileCases : (Phi.Pattern × Phi.Expr)* × Ctx ⇄ (RVM.Instr* × Ctx)\n\n  rule compileCases {\n    ([], ctx)\n      ↦ ([RVM.IHalt], ctx)    // No match"))
    Gt
    Push(Str("ctx1) in\n        ( [RVM.ITestTag(tag), RVM.IJumpIfNot(length(cBody"))
    Push(Str("body"))
    Push(Str("pats"))
    Push(Str("ctx2) = compileConCase(tag"))
    Push(Str("ctx) in\n        let restLen = length(cRest) in\n        let (cBody"))
    Push(Str("ctx1) = compileCases(rest"))
    Push(Str("ctx)\n      ↦ let (cRest"))
    Push(Str("Ctx(scope, lc', blocks', errs'))\n\n    ([(Phi.PCon(name, tag, pats), body) | rest]"))
    Push(Str("Ctx(scope', lc, blocks, errs)) in\n        (cBody ++ [RVM.ISwap, RVM.IPop]"))
    Push(Str("Ctx(_, lc', blocks', errs')) = \n              compile(body"))
    Push(Str("scope) in\n        let (cBody"))
    Push(Str("slot"))
    Push(Str("Ctx(scope, lc, blocks, errs))\n      ↦ let slot = scopeSize(scope) in\n        let scope' = ScopeBind(x"))
    Push(Str("ctx')\n\n    ([(Phi.PVar(x), body) | _]"))
    Push(Str("ctx) in\n        (cBody"))
    Push(Str("ctx') = compile(body"))
    Push(Str("ctx)\n      ↦ let (cBody"))
    Push(Nil)
    Push(Str("(Phi.PWild, body) | _"))
    Swap
    Cons
    Push(Str("error"))
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Apply
    Sub
    Push(Str("1)]\n          ++ cBody\n          ++ [RVM.IJump(restLen"))
    Push(Str("1)]\n          ++ cRest\n        , ctx2)\n  }\n\n  xform compileConCase : Int × Phi.Pattern* × Phi.Expr × Ctx ⇄ (RVM.Instr* × Ctx)\n\n  rule compileConCase {\n    (tag, pats, body, ctx)\n      ↦ let n = length(pats) in\n        // Unpack constructor fields onto stack\n        // Then compile body with patterns bound\n        ([RVM.IUnpack(n)] ++ compilePatBinds(pats, 0) ++ cBody, ctx')\n      where (cBody, ctx') = compile(body, extendScopeWithPats(pats, ctx))\n  }\n\n  // ---------------------------------------------------------------------------\n  // Helpers\n  // ---------------------------------------------------------------------------\n\n  // Compile a list of expressions\n  xform compileList : Phi.Expr* × Ctx ⇄ (RVM.Instr* × Ctx)\n\n  rule compileList {\n    ([], ctx) ↦ ([], ctx)\n    ([e | es], ctx) \n      ↦ let (c, ctx1) = compile(e, ctx) in\n        let (cs, ctx2) = compileList(es, ctx1) in\n        (c ++ cs, ctx2)\n  }\n\n  // Count scope size\n  xform scopeSize : Scope ⇄ Int\n  rule scopeSize {\n    ScopeEmpty            ↦ 0\n    ScopeBind(_, _, rest) ↦ 1"))
    Push(Str("scopeSize(rest)\n  }\n\n  // ===========================================================================\n  // Top-Level Compilation\n  // ===========================================================================\n\n  // Compile a definition\n  xform compileDef : Phi.Def × Ctx ⇄ (RVM.CodeBlock × Ctx)\n\n  rule compileDef {\n    (Phi.Def(name, params, body), ctx)\n      ↦ let paramScope = foldl(\n              fn(s, (p, i)) → ScopeBind(p, i, s),\n              ScopeEmpty,\n              zip(params, range(0, length(params)))\n            ) in\n        let (cBody, ctx') = compile(body, Ctx(paramScope, 0, [], [])) in\n        let code = cBody ++ [RVM.IHalt] in\n        let hash = hashOf(name) in\n        let block = RVM.CodeBlock(\n              hash, \n              Some(name), \n              length(params), \n              0, \n              0, \n              code\n            ) in\n        (block, ctx')\n  }\n\n  // Compile a module (list of definitions)\n  xform compileModule : Phi.Def* ⇄ RVM.Program\n\n  rule compileModule {\n    defs ↦ \n      let blocks = map(fn(d) → fst(compileDef(d, emptyCtx)), defs) in\n      let mainHash = findMain(defs) in\n      RVM.Program(blocks, mainHash)\n  }\n\n  def emptyCtx : Ctx = Ctx(ScopeEmpty, 0, [], [])\n\n  // ===========================================================================\n  // Code Generation: Render to .rvm\n  // ===========================================================================\n\n  xform renderProgram : RVM.Program ⇄ String\n\n  rule renderProgram {\n    RVM.Program(blocks, mainHash)\n      ↦ intercalate(\"\\n\\n\", map(renderBlock, blocks))\n  }\n\n  xform renderBlock : RVM.CodeBlock ⇄ String\n\n  rule renderBlock {\n    RVM.CodeBlock(hash, Some(name), arity, locals, captures, instrs)\n      ↦ \"fn \" ++ name ++ \"(\" ++ renderParams(arity) ++ \") {\\n\"\n        ++ indent(4, intercalate(\"\\n\", map(renderInstr, instrs)))\n        ++ \"\\n}\"\n  }\n\n  xform renderInstr : RVM.Instr ⇄ String\n\n  rule renderInstr {\n    RVM.IPush(RVM.LInt(n))    ↦ \"push \" ++ toString(n)\n    RVM.IPush(RVM.LStr(s))    ↦ \"push \\\"\" ++ escape(s) ++ \"\\\"\"\n    RVM.IPush(RVM.LBool(b))   ↦ \"push \" ++ if b then \"true\" else \"false\"\n    RVM.IPush(RVM.LUnit)      ↦ \"push ()\"\n    RVM.IPush(RVM.LNil)       ↦ \"push nil\"\n    RVM.IPop                  ↦ \"pop\"\n    RVM.IDup                  ↦ \"dup\"\n    RVM.ISwap                 ↦ \"swap\"\n    RVM.IRot                  ↦ \"rot\"\n    RVM.IOver                 ↦ \"over\"\n    RVM.ILoad(n)              ↦ \"load \" ++ toString(n)\n    RVM.IStore(n)             ↦ \"store \" ++ toString(n)\n    RVM.IAdd                  ↦ \"add\"\n    RVM.ISub                  ↦ \"sub\"\n    RVM.IMul                  ↦ \"mul\"\n    RVM.IDiv                  ↦ \"div\"\n    RVM.IMod                  ↦ \"mod\"\n    RVM.INeg                  ↦ \"neg\"\n    RVM.IEq                   ↦ \"eq\"\n    RVM.INe                   ↦ \"ne\"\n    RVM.ILt                   ↦ \"lt\"\n    RVM.ILe                   ↦ \"le\"\n    RVM.IGt                   ↦ \"gt\"\n    RVM.IGe                   ↦ \"ge\"\n    RVM.INot                  ↦ \"not\"\n    RVM.IAnd                  ↦ \"and\"\n    RVM.IOr                   ↦ \"or\"\n    RVM.IJump(n)              ↦ \"jump \" ++ toString(n)\n    RVM.IJumpIf(n)            ↦ \"jt \" ++ toString(n)\n    RVM.IJumpIfNot(n)         ↦ \"jf \" ++ toString(n)\n    RVM.ICall(h)              ↦ \"call \" ++ hashName(h)\n    RVM.ITailCall(h)          ↦ \"tailcall \" ++ hashName(h)\n    RVM.IReturn               ↦ \"ret\"\n    RVM.IHalt                 ↦ \"halt\"\n    RVM.IClosure(h, n)        ↦ \"closure \" ++ hashName(h) ++ \" \" ++ toString(n)\n    RVM.IApply                ↦ \"apply\"\n    RVM.IApplyN(n)            ↦ \"applyn \" ++ toString(n)\n    RVM.IMkTuple(n)           ↦ \"tuple \" ++ toString(n)\n    RVM.IMkList(n)            ↦ \"list \" ++ toString(n)\n    RVM.IMkCon(h, tag, n)     ↦ \"con \" ++ hashName(h) ++ \" \" ++ toString(tag) ++ \" \" ++ toString(n)\n    RVM.IGetField(n)          ↦ \"field \" ++ toString(n)\n    RVM.IUnpack(n)            ↦ \"unpack \" ++ toString(n)\n    RVM.ITestTag(n)           ↦ \"testtag \" ++ toString(n)\n    RVM.ICons                 ↦ \"cons\"\n    RVM.IHead                 ↦ \"head\"\n    RVM.ITail                 ↦ \"tail\"\n    RVM.IIsNil                ↦ \"isnil\"\n    RVM.ILen                  ↦ \"len\"\n    RVM.IConcat               ↦ \"concat\"\n    RVM.IIndex                ↦ \"index\"\n    RVM.IPrint                ↦ \"print\"\n    RVM.ITrace                ↦ \"trace\"\n    RVM.IAssert               ↦ \"assert\"\n    RVM.INop                  ↦ \"nop\"\n  }\n\n  // ===========================================================================\n  // Example: Quicksort compilation\n  // ===========================================================================\n\n  // Input (Phi):\n  //   def quicksort(xs) =\n  //     match xs with\n  //       [] → []\n  //       [p | rest] → \n  //         let smaller = filter(fn(x) → x"))
    Push(Str("p, rest)\n  //         let larger = filter(fn(x) → x >= p, rest)\n  //         quicksort(smaller) ++ [p] ++ quicksort(larger)\n\n  // Output (.rvm):\n  //   fn quicksort(xs) {\n  //       load 0\n  //       isnil\n  //       jf 3\n  //       push nil\n  //       ret\n  //       load 0\n  //       head\n  //       load 0\n  //       tail\n  //       ... (filter, recursive calls, concat)\n  //   }\n}"))
    Lt
    Add
    Add
    Add
    Add
    Add
    Add
    Add
    Add
    halt
}
